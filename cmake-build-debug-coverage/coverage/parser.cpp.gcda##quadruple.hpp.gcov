        -:    0:Source:D:/programming/c/tac_parser/tac_worker/quadruple.hpp
        -:    0:Graph:D:\programming\c\tac_parser\cmake-build-debug-coverage\CMakeFiles\tac_parser.dir\parser.cpp.gcno
        -:    0:Data:D:\programming\c\tac_parser\cmake-build-debug-coverage\CMakeFiles\tac_parser.dir\parser.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#ifndef TAC_PARSER_QUADRUPLE_HPP
        -:    2:#define TAC_PARSER_QUADRUPLE_HPP
        -:    3:
        -:    4:#include <string>
        -:    5:#include <ostream>
        -:    6:#include <utility>
        -:    7:#include <vector>
        -:    8:#include <optional>
        -:    9:#include <iostream>
        -:   10:
        -:   11:
        -:   12:struct Dest {
        -:   13:    enum class Type {
        -:   14:        None, Var, ArraySet, Deref, JumpLabel,
        -:   15:    };
        -:   16:
        -:   17:    Type dest_type{};
        -:   18:    std::string dest_name;
        -:   19:    std::optional<std::string> element_name;
        -:   20:
    #####:   21:    Dest(std::string dest_name, std::optional<std::string> element_name, Type dest_type)
    #####:   22:            : dest_name(std::move(dest_name)), element_name(std::move(element_name)), dest_type(dest_type) {}
    %%%%%:   22-block  0
        -:   23:
    #####:   24:    Dest() = default;
    %%%%%:   24-block  0
    %%%%%:   24-block  1
    $$$$$:   24-block  2
        -:   25:
        -:   26:    friend std::ostream &operator<<(std::ostream &os, const Dest &destination) {
        -:   27:        const char *type_names[] = {"None", "Var", "ArraySet", "Deref", "JumpLabel"};
        -:   28:        os << "dest_type: " << type_names[static_cast<int>(destination.dest_type)]
        -:   29:           << "; dest_name: " << destination.dest_name;
        -:   30:        if (destination.element_name.has_value()) os << "; element_name: " << destination.element_name.value();
        -:   31:        return os;
        -:   32:    }
        -:   33:
        -:   34:    std::optional<std::string> fmt() const {
        -:   35:        switch (dest_type) {
        -:   36:            case Type::Var:
        -:   37:                return dest_name;
        -:   38:            case Type::ArraySet:
        -:   39:                return dest_name + "[" + element_name.value() + "]";
        -:   40:            case Type::Deref:
        -:   41:                return "*" + dest_name;
        -:   42:            case Type::JumpLabel:
        -:   43:                return dest_name;
        -:   44:            default:
        -:   45:                return {};
        -:   46:        }
        -:   47:    }
        -:   48:};
        -:   49:
        -:   50:
        -:   51:struct Operand {
        -:   52:    enum class Type {
        -:   53:        None, Var, LInt, LDouble, LBool, LChar
        -:   54:    };
        -:   55:
        -:   56:    std::string value;
        -:   57:    Type type;
        -:   58:
        -:   59:    Operand() : type(Type::None) {}
        -:   60:
        -:   61:    Operand(std::string s, Type t) : value(std::move(s)), type(t) {}
        -:   62:
    #####:   63:    Operand(const std::string &s) {
    %%%%%:   63-block  0
    $$$$$:   63-block  1
    #####:   64:        char *end = nullptr;
    #####:   65:        if (strtol(s.c_str(), &end, 10); end != s.c_str() && *end == '\0') {
    %%%%%:   65-block  0
    %%%%%:   65-block  1
    %%%%%:   65-block  2
    %%%%%:   65-block  3
    #####:   66:            type = Type::LInt;
    %%%%%:   66-block  0
    #####:   67:        } else if (strtod(s.c_str(), &end); end != s.c_str() && *end == '\0') {
    %%%%%:   67-block  0
    %%%%%:   67-block  1
    %%%%%:   67-block  2
    %%%%%:   67-block  3
    %%%%%:   67-block  4
    #####:   68:            type = Type::LDouble;
    %%%%%:   68-block  0
    #####:   69:        } else if (!s.empty()) {
    %%%%%:   69-block  0
    #####:   70:            type = Type::Var;
    %%%%%:   70-block  0
        -:   71:        } else {
    #####:   72:            type = Type::None;
    %%%%%:   72-block  0
        -:   73:        }
    #####:   74:        value = s;
    %%%%%:   74-block  0
    #####:   75:    }
    %%%%%:   75-block  0
        -:   76:
        -:   77:    std::string get_string() const {
        -:   78:        return value;
        -:   79:    }
        -:   80:
        -:   81:    int get_int() const {
        -:   82:        char *end = nullptr;
        -:   83:        return strtol(value.c_str(), &end, 10);
        -:   84:    }
        -:   85:
        -:   86:    double get_double() const {
        -:   87:        char *end = nullptr;
        -:   88:        return strtod(value.c_str(), &end);
        -:   89:    }
        -:   90:
        -:   91:    bool is_var() const { return type == Type::Var; }
        -:   92:
        -:   93:    bool is_int() const { return type == Type::LInt; }
        -:   94:
        -:   95:    bool is_double() const { return type == Type::LDouble; }
        -:   96:
        -:   97:    bool is_number() const {
        -:   98:        return type == Type::LInt || type == Type::LDouble;
        -:   99:    }
        -:  100:
        -:  101:    void clear() {
        -:  102:        value.clear();
        -:  103:        type = Type::None;
        -:  104:    }
        -:  105:
        -:  106:    bool operator==(const Operand &rhs) const {
        -:  107:        if (is_number() && rhs.is_number())
        -:  108:            return get_double() == rhs.get_double();
        -:  109:        else
        -:  110:            return value == rhs.value;
        -:  111:    }
        -:  112:
        -:  113:};
        -:  114:
        -:  115:struct Quad {
        -:  116:    enum class Type {
        -:  117:        Nop, Add, Sub, Mult, Div, UMinus,
        -:  118:        Lt, Gt, Eq, Neq,
        -:  119:        Assign, Deref, Ref, ArrayGet,
        -:  120:        IfTrue, IfFalse, Goto, Halt, Call, Param, Return,
        -:  121:        PhiNode,
        -:  122:    };
        -:  123:
        -:  124:    std::optional<Dest> dest{};
        -:  125:
        -:  126:    std::vector<Operand> ops{};
        -:  127://    Operand op1{};
        -:  128://    Operand op2{};
        -:  129:    Type type{};
        -:  130:
        -:  131:
    #####:  132:    Quad(std::string op1, std::string op2, Type op_type, const Dest &dest = {})
    #####:  133:            : type(op_type), dest(dest) {
    %%%%%:  133-block  0
    $$$$$:  133-block  1
    $$$$$:  133-block  2
    #####:  134:        if (!op1.empty()) ops.emplace_back(std::move(op1));
    %%%%%:  134-block  0
    #####:  135:        if (!op2.empty()) ops.emplace_back(std::move(op2));
    %%%%%:  135-block  0
    %%%%%:  135-block  1
    #####:  136:    }
    %%%%%:  136-block  0
        -:  137:
       74:  138:    Quad() = default;
       74:  138-block  0
        -:  139:
        -:  140:    static bool is_commutative(Type t) {
        -:  141:        return t == Type::Add || t == Type::Mult || t == Type::Assign
        -:  142:               || t == Type::Eq || t == Type::Neq;
        -:  143:    }
        -:  144:
        -:  145:    static bool is_jump(Type t) {
        -:  146:        return t == Type::Goto || t == Type::IfTrue || t == Type::IfFalse;
        -:  147:    }
        -:  148:
        -:  149:    std::vector<std::string> get_used_vars() const {
        -:  150:        auto used_vars = get_rhs();
        -:  151:        if (auto l = get_lhs(); l.has_value()) {
        -:  152:            used_vars.push_back(l.value());
        -:  153:        }
        -:  154:        return used_vars;
        -:  155:    }
        -:  156:
        -:  157:    std::optional<std::string> get_lhs() const {
        -:  158:        if (dest && !is_jump()) {
        -:  159:            return (dest.value().dest_name);
        -:  160:        } else {
        -:  161:            return {};
        -:  162:        }
        -:  163:    }
        -:  164:
        -:  165:    void clear_op(int i) {
        -:  166:        ops.erase(ops.begin() + i);
        -:  167:    }
        -:  168:
        -:  169:    std::optional<Operand> get_op(int i) const {
        -:  170:        if (ops.size() > i)
        -:  171:            return ops.at(i);
        -:  172:        else return {};
        -:  173:    }
        -:  174:
        -:  175:    std::vector<std::string> get_rhs(bool include_constants = true) const {
        -:  176:        std::vector<std::string> rhs_vars;
        -:  177:        if (dest) {
        -:  178:            if (dest.value().dest_type == Dest::Type::ArraySet)
        -:  179:                rhs_vars.push_back(dest.value().element_name.value());
        -:  180:        }
        -:  181:        auto op1 = get_op(0);
        -:  182:        auto op2 = get_op(1);
        -:  183:
        -:  184:        if (op1 && !op1->value.empty() && (include_constants || op1->is_var())) rhs_vars.push_back(op1->get_string());
        -:  185:        if (op2 && !op2->value.empty() && (include_constants || op2->is_var())) rhs_vars.push_back(op2->get_string());
        -:  186:        return rhs_vars;
        -:  187:    }
        -:  188:
        -:  189:    bool is_jump() const {
        -:  190:        return type == Type::Goto
        -:  191:               || type == Type::IfTrue
        -:  192:               || type == Type::IfFalse;
        -:  193:    }
        -:  194:
        -:  195:
        -:  196:    friend std::ostream &operator<<(std::ostream &os, const Quad &quad) {
        -:  197:        const char *type_names[] = {"Nop", "Add", "Sub", "Mult", "Div", "UMinus", "Lt", "Gt", "Eq", "Neq", "Assign",
        -:  198:                                    "Deref", "Ref", "ArrayGet", "IfTrue", "IfFalse", "Goto", "Halt", "Call", "Param",
        -:  199:                                    "Return", "PhiNode"};
        -:  200:        if (quad.dest.has_value()) os << "dest: { " << quad.dest.value() << "}" << "; ";
        -:  201:        if (quad.get_op(0)->type != Operand::Type::None)
        -:  202:            os << "op1: " << quad.get_op(0)->get_string() << "; ";
        -:  203:        if (quad.get_op(1)->type != Operand::Type::None)
        -:  204:            os << "op2: " << quad.get_op(1)->get_string() << "; ";
        -:  205:        os << "type: " << type_names[static_cast<int>(quad.type)];
        -:  206:        return os;
        -:  207:    }
        -:  208:
        -:  209:
        -:  210:    std::string fmt() const {
        -:  211:        std::optional<std::string> destination = dest.has_value() ? dest.value().fmt() : std::nullopt;
        -:  212:
        -:  213:        std::string command;
        -:  214:        if (destination.has_value()) {
        -:  215:            command += destination.value() + " = ";
        -:  216:        }
        -:  217:
        -:  218:        std::optional<std::string> op;
        -:  219:        std::optional<std::string> unary_op;
        -:  220:        switch (type) {
        -:  221:            case Type::Add:
        -:  222:                op = "+";
        -:  223:                break;
        -:  224:            case Type::Sub:
        -:  225:                op = "-";
        -:  226:                break;
        -:  227:            case Type::Mult:
        -:  228:                op = "*";
        -:  229:                break;
        -:  230:            case Type::Div:
        -:  231:                op = "/";
        -:  232:                break;
        -:  233:            case Type::UMinus:
        -:  234:                unary_op = "-";
        -:  235:                break;
        -:  236:            case Type::Lt:
        -:  237:                op = "<";
        -:  238:                break;
        -:  239:            case Type::Gt:
        -:  240:                op = ">";
        -:  241:                break;
        -:  242:            case Type::Eq:
        -:  243:                op = "==";
        -:  244:                break;
        -:  245:            case Type::Neq:
        -:  246:                op = "!=";
        -:  247:                break;
        -:  248:            case Type::Assign:
        -:  249:                unary_op = "";
        -:  250:                break;
        -:  251:            case Type::Deref:
        -:  252:                unary_op = "*";
        -:  253:                break;
        -:  254:            case Type::Ref:
        -:  255:                unary_op = "&";
        -:  256:                break;
        -:  257:            case Type::ArrayGet:
        -:  258:                return destination.value() + " = " + get_op(0)->get_string() + "[" + get_op(1)->get_string() + "]";
        -:  259:            case Type::IfTrue:
        -:  260:                return "if " + get_op(0)->get_string() + " goto " + destination.value();
        -:  261:            case Type::IfFalse:
        -:  262:                return "ifFalse " + get_op(0)->get_string() + " goto " + destination.value();
        -:  263:            case Type::Goto:
        -:  264:                return "goto " + destination.value();
        -:  265:            case Type::Halt:
        -:  266:                return "halt";
        -:  267:            case Type::Call:
        -:  268:                return "call " + get_op(0)->get_string() + " " + get_op(0)->get_string();
        -:  269:            case Type::Param:
        -:  270:                return "param " + get_op(0)->get_string();
        -:  271:            case Type::Nop:
        -:  272:                return "nop";
        -:  273:            case Type::Return:
        -:  274:                return "return";
        -:  275:            case Type::PhiNode:
        -:  276:                std::string output;
        -:  277:                for (auto &op : ops)
        -:  278:                    output += op.value + " ";
        -:  279:                return destination.value() + " = phi ( " + output + ")";
        -:  280:        }
        -:  281:
        -:  282:        if (unary_op.has_value()) {
        -:  283:            return destination.value() + " = " + unary_op.value() + get_op(0)->get_string();
        -:  284:        } else {
        -:  285:            return destination.value() + " = " + get_op(0)->get_string() + op.value() + get_op(1)->get_string();
        -:  286:        }
        -:  287:    }
        -:  288:};
        -:  289:
        -:  290:
        -:  291:#endif //TAC_PARSER_QUADRUPLE_HPP
        -:  292:
        -:  293:
