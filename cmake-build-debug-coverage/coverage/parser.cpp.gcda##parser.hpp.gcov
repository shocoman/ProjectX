        -:    0:Source:D:/programming/c/tac_parser/cmake-build-debug-coverage/parser.hpp
        -:    0:Graph:D:\programming\c\tac_parser\cmake-build-debug-coverage\CMakeFiles\tac_parser.dir\parser.cpp.gcno
        -:    0:Data:D:\programming\c\tac_parser\cmake-build-debug-coverage\CMakeFiles\tac_parser.dir\parser.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// A Bison parser, made by GNU Bison 3.7.1.
        -:    2:
        -:    3:// Skeleton interface for Bison LALR(1) parsers in C++
        -:    4:
        -:    5:// Copyright (C) 2002-2015, 2018-2020 Free Software Foundation, Inc.
        -:    6:
        -:    7:// This program is free software: you can redistribute it and/or modify
        -:    8:// it under the terms of the GNU General Public License as published by
        -:    9:// the Free Software Foundation, either version 3 of the License, or
        -:   10:// (at your option) any later version.
        -:   11:
        -:   12:// This program is distributed in the hope that it will be useful,
        -:   13:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   14:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   15:// GNU General Public License for more details.
        -:   16:
        -:   17:// You should have received a copy of the GNU General Public License
        -:   18:// along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   19:
        -:   20:// As a special exception, you may create a larger work that contains
        -:   21:// part or all of the Bison parser skeleton and distribute that work
        -:   22:// under terms of your choice, so long as that work isn't itself a
        -:   23:// parser generator using the skeleton or a modified version thereof
        -:   24:// as a parser skeleton.  Alternatively, if you modify or redistribute
        -:   25:// the parser skeleton itself, you may (at your option) remove this
        -:   26:// special exception, which will cause the skeleton and the resulting
        -:   27:// Bison output files to be licensed under the GNU General Public
        -:   28:// License without this special exception.
        -:   29:
        -:   30:// This special exception was added by the Free Software Foundation in
        -:   31:// version 2.2 of Bison.
        -:   32:
        -:   33:
        -:   34:/**
        -:   35: ** \file D:/programming/c/tac_parser/cmake-build-debug-coverage/parser.hpp
        -:   36: ** Define the yy::parser class.
        -:   37: */
        -:   38:
        -:   39:// C++ LALR(1) parser skeleton written by Akim Demaille.
        -:   40:
        -:   41:// DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
        -:   42:// especially those whose name start with YY_ or yy_.  They are
        -:   43:// private implementation details that can be changed or removed.
        -:   44:
        -:   45:#ifndef YY_YY_D_PROGRAMMING_C_TAC_PARSER_CMAKE_BUILD_DEBUG_COVERAGE_PARSER_HPP_INCLUDED
        -:   46:# define YY_YY_D_PROGRAMMING_C_TAC_PARSER_CMAKE_BUILD_DEBUG_COVERAGE_PARSER_HPP_INCLUDED
        -:   47:// "%code requires" blocks.
        -:   48:#line 10 "D:/programming/c/tac_parser/grammar/parser.y"
        -:   49:
        -:   50:    #include <string>
        -:   51:    struct driver;
        -:   52:    #include "../tac_worker/quadruple.hpp"
        -:   53:
        -:   54:#line 55 "D:/programming/c/tac_parser/cmake-build-debug-coverage/parser.hpp"
        -:   55:
        -:   56:# include <cassert>
        -:   57:# include <cstdlib> // std::abort
        -:   58:# include <iostream>
        -:   59:# include <stdexcept>
        -:   60:# include <string>
        -:   61:# include <vector>
        -:   62:
        -:   63:#if defined __cplusplus
        -:   64:# define YY_CPLUSPLUS __cplusplus
        -:   65:#else
        -:   66:# define YY_CPLUSPLUS 199711L
        -:   67:#endif
        -:   68:
        -:   69:// Support move semantics when possible.
        -:   70:#if 201103L <= YY_CPLUSPLUS
        -:   71:# define YY_MOVE           std::move
        -:   72:# define YY_MOVE_OR_COPY   move
        -:   73:# define YY_MOVE_REF(Type) Type&&
        -:   74:# define YY_RVREF(Type)    Type&&
        -:   75:# define YY_COPY(Type)     Type
        -:   76:#else
        -:   77:# define YY_MOVE
        -:   78:# define YY_MOVE_OR_COPY   copy
        -:   79:# define YY_MOVE_REF(Type) Type&
        -:   80:# define YY_RVREF(Type)    const Type&
        -:   81:# define YY_COPY(Type)     const Type&
        -:   82:#endif
        -:   83:
        -:   84:// Support noexcept when possible.
        -:   85:#if 201103L <= YY_CPLUSPLUS
        -:   86:# define YY_NOEXCEPT noexcept
        -:   87:# define YY_NOTHROW
        -:   88:#else
        -:   89:# define YY_NOEXCEPT
        -:   90:# define YY_NOTHROW throw ()
        -:   91:#endif
        -:   92:
        -:   93:// Support constexpr when possible.
        -:   94:#if 201703 <= YY_CPLUSPLUS
        -:   95:# define YY_CONSTEXPR constexpr
        -:   96:#else
        -:   97:# define YY_CONSTEXPR
        -:   98:#endif
        -:   99:# include "location.hh"
        -:  100:#include <typeinfo>
        -:  101:#ifndef YY_ASSERT
        -:  102:# include <cassert>
        -:  103:# define YY_ASSERT assert
        -:  104:#endif
        -:  105:
        -:  106:
        -:  107:#ifndef YY_ATTRIBUTE_PURE
        -:  108:# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
        -:  109:#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
        -:  110:# else
        -:  111:#  define YY_ATTRIBUTE_PURE
        -:  112:# endif
        -:  113:#endif
        -:  114:
        -:  115:#ifndef YY_ATTRIBUTE_UNUSED
        -:  116:# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
        -:  117:#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
        -:  118:# else
        -:  119:#  define YY_ATTRIBUTE_UNUSED
        -:  120:# endif
        -:  121:#endif
        -:  122:
        -:  123:/* Suppress unused-variable warnings by "using" E.  */
        -:  124:#if ! defined lint || defined __GNUC__
        -:  125:# define YYUSE(E) ((void) (E))
        -:  126:#else
        -:  127:# define YYUSE(E) /* empty */
        -:  128:#endif
        -:  129:
        -:  130:#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
        -:  131:/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
        -:  132:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                            \
        -:  133:    _Pragma ("GCC diagnostic push")                                     \
        -:  134:    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
        -:  135:    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
        -:  136:# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
        -:  137:    _Pragma ("GCC diagnostic pop")
        -:  138:#else
        -:  139:# define YY_INITIAL_VALUE(Value) Value
        -:  140:#endif
        -:  141:#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  142:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  143:# define YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  144:#endif
        -:  145:#ifndef YY_INITIAL_VALUE
        -:  146:# define YY_INITIAL_VALUE(Value) /* Nothing. */
        -:  147:#endif
        -:  148:
        -:  149:#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
        -:  150:# define YY_IGNORE_USELESS_CAST_BEGIN                          \
        -:  151:    _Pragma ("GCC diagnostic push")                            \
        -:  152:    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
        -:  153:# define YY_IGNORE_USELESS_CAST_END            \
        -:  154:    _Pragma ("GCC diagnostic pop")
        -:  155:#endif
        -:  156:#ifndef YY_IGNORE_USELESS_CAST_BEGIN
        -:  157:# define YY_IGNORE_USELESS_CAST_BEGIN
        -:  158:# define YY_IGNORE_USELESS_CAST_END
        -:  159:#endif
        -:  160:
        -:  161:# ifndef YY_CAST
        -:  162:#  ifdef __cplusplus
        -:  163:#   define YY_CAST(Type, Val) static_cast<Type> (Val)
        -:  164:#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
        -:  165:#  else
        -:  166:#   define YY_CAST(Type, Val) ((Type) (Val))
        -:  167:#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
        -:  168:#  endif
        -:  169:# endif
        -:  170:# ifndef YY_NULLPTR
        -:  171:#  if defined __cplusplus
        -:  172:#   if 201103L <= __cplusplus
        -:  173:#    define YY_NULLPTR nullptr
        -:  174:#   else
        -:  175:#    define YY_NULLPTR 0
        -:  176:#   endif
        -:  177:#  else
        -:  178:#   define YY_NULLPTR ((void*)0)
        -:  179:#  endif
        -:  180:# endif
        -:  181:
        -:  182:/* Debug traces.  */
        -:  183:#ifndef YYDEBUG
        -:  184:# define YYDEBUG 1
        -:  185:#endif
        -:  186:
        -:  187:namespace yy {
        -:  188:#line 189 "D:/programming/c/tac_parser/cmake-build-debug-coverage/parser.hpp"
        -:  189:
        -:  190:
        -:  191:
        -:  192:
        -:  193:  /// A Bison parser.
        -:  194:  class parser
        -:  195:  {
        -:  196:  public:
        -:  197:#ifndef YYSTYPE
        -:  198:  /// A buffer to store and retrieve objects.
        -:  199:  ///
        -:  200:  /// Sort of a variant, but does not keep track of the nature
        -:  201:  /// of the stored data, since that knowledge is available
        -:  202:  /// via the current parser state.
        -:  203:  class semantic_type
        -:  204:  {
        -:  205:  public:
        -:  206:    /// Type of *this.
        -:  207:    typedef semantic_type self_type;
        -:  208:
        -:  209:    /// Empty construction.
     1459:  210:    semantic_type () YY_NOEXCEPT
     1459:  211:      : yybuffer_ ()
     1459:  212:      , yytypeid_ (YY_NULLPTR)
     1459:  213:    {}
        -:  214:
        -:  215:    /// Construct and fill.
        -:  216:    template <typename T>
        -:  217:    semantic_type (YY_RVREF (T) t)
        -:  218:      : yytypeid_ (&typeid (T))
        -:  219:    {
        -:  220:      YY_ASSERT (sizeof (T) <= size);
        -:  221:      new (yyas_<T> ()) T (YY_MOVE (t));
        -:  222:    }
        -:  223:
        -:  224:#if 201103L <= YY_CPLUSPLUS
        -:  225:    /// Non copyable.
        -:  226:    semantic_type (const self_type&) = delete;
        -:  227:    /// Non copyable.
        -:  228:    self_type& operator= (const self_type&) = delete;
        -:  229:#endif
        -:  230:
        -:  231:    /// Destruction, allowed only if empty.
     1524:  232:    ~semantic_type () YY_NOEXCEPT
     1524:  233:    {
    1524*:  234:      YY_ASSERT (!yytypeid_);
     1524:  234-block  0
    %%%%%:  234-block  1
     1524:  234-block  2
     1524:  235:    }
        -:  236:
        -:  237:# if 201103L <= YY_CPLUSPLUS
        -:  238:    /// Instantiate a \a T in here from \a t.
        -:  239:    template <typename T, typename... U>
        -:  240:    T&
     463*:  241:    emplace (U&&... u)
        -:  242:    {
     463*:  243:      YY_ASSERT (!yytypeid_);
        -:  244:      YY_ASSERT (sizeof (T) <= size);
     463*:  245:      yytypeid_ = & typeid (T);
     597*:  246:      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
        -:  247:    }
------------------
_ZN2yy6parser13semantic_type7emplaceINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJS8_EEERT_DpOT0_:
      183:  241:    emplace (U&&... u)
        -:  242:    {
     183*:  243:      YY_ASSERT (!yytypeid_);
      183:  243-block  0
    %%%%%:  243-block  1
      183:  243-block  2
        -:  244:      YY_ASSERT (sizeof (T) <= size);
      183:  245:      yytypeid_ = & typeid (T);
      183:  246:      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
      183:  246-block  0
        -:  247:    }
------------------
_ZN2yy6parser13semantic_type7emplaceIiJiEEERT_DpOT0_:
       51:  241:    emplace (U&&... u)
        -:  242:    {
      51*:  243:      YY_ASSERT (!yytypeid_);
       51:  243-block  0
    %%%%%:  243-block  1
       51:  243-block  2
        -:  244:      YY_ASSERT (sizeof (T) <= size);
       51:  245:      yytypeid_ = & typeid (T);
       51:  246:      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
       51:  246-block  0
        -:  247:    }
------------------
_ZN2yy6parser13semantic_type7emplaceIdJdEEERT_DpOT0_:
    #####:  241:    emplace (U&&... u)
        -:  242:    {
    #####:  243:      YY_ASSERT (!yytypeid_);
    %%%%%:  243-block  0
    %%%%%:  243-block  1
    %%%%%:  243-block  2
        -:  244:      YY_ASSERT (sizeof (T) <= size);
    #####:  245:      yytypeid_ = & typeid (T);
    #####:  246:      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
    %%%%%:  246-block  0
        -:  247:    }
------------------
_ZN2yy6parser13semantic_type7emplaceI4QuadJS3_EEERT_DpOT0_:
       74:  241:    emplace (U&&... u)
        -:  242:    {
      74*:  243:      YY_ASSERT (!yytypeid_);
       74:  243-block  0
    %%%%%:  243-block  1
       74:  243-block  2
        -:  244:      YY_ASSERT (sizeof (T) <= size);
       74:  245:      yytypeid_ = & typeid (T);
       74:  246:      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
       74:  246-block  0
        -:  247:    }
------------------
_ZN2yy6parser13semantic_type7emplaceI4DestJS3_EEERT_DpOT0_:
       21:  241:    emplace (U&&... u)
        -:  242:    {
      21*:  243:      YY_ASSERT (!yytypeid_);
       21:  243-block  0
    %%%%%:  243-block  1
       21:  243-block  2
        -:  244:      YY_ASSERT (sizeof (T) <= size);
       21:  245:      yytypeid_ = & typeid (T);
       21:  246:      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
       21:  246-block  0
        -:  247:    }
------------------
_ZN2yy6parser13semantic_type7emplaceINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEEERT_DpOT0_:
       39:  241:    emplace (U&&... u)
        -:  242:    {
      39*:  243:      YY_ASSERT (!yytypeid_);
       39:  243-block  0
    %%%%%:  243-block  1
       39:  243-block  2
        -:  244:      YY_ASSERT (sizeof (T) <= size);
       39:  245:      yytypeid_ = & typeid (T);
       78:  246:      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
       39:  246-block  0
        -:  247:    }
------------------
_ZN2yy6parser13semantic_type7emplaceIiJEEERT_DpOT0_:
    #####:  241:    emplace (U&&... u)
        -:  242:    {
    #####:  243:      YY_ASSERT (!yytypeid_);
    %%%%%:  243-block  0
    %%%%%:  243-block  1
    %%%%%:  243-block  2
        -:  244:      YY_ASSERT (sizeof (T) <= size);
    #####:  245:      yytypeid_ = & typeid (T);
    #####:  246:      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
    %%%%%:  246-block  0
        -:  247:    }
------------------
_ZN2yy6parser13semantic_type7emplaceIdJEEERT_DpOT0_:
    #####:  241:    emplace (U&&... u)
        -:  242:    {
    #####:  243:      YY_ASSERT (!yytypeid_);
    %%%%%:  243-block  0
    %%%%%:  243-block  1
    %%%%%:  243-block  2
        -:  244:      YY_ASSERT (sizeof (T) <= size);
    #####:  245:      yytypeid_ = & typeid (T);
    #####:  246:      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
    %%%%%:  246-block  0
        -:  247:    }
------------------
_ZN2yy6parser13semantic_type7emplaceI4QuadJEEERT_DpOT0_:
       74:  241:    emplace (U&&... u)
        -:  242:    {
      74*:  243:      YY_ASSERT (!yytypeid_);
       74:  243-block  0
    %%%%%:  243-block  1
       74:  243-block  2
        -:  244:      YY_ASSERT (sizeof (T) <= size);
       74:  245:      yytypeid_ = & typeid (T);
      148:  246:      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
       74:  246-block  0
        -:  247:    }
------------------
_ZN2yy6parser13semantic_type7emplaceI4DestJEEERT_DpOT0_:
       21:  241:    emplace (U&&... u)
        -:  242:    {
      21*:  243:      YY_ASSERT (!yytypeid_);
       21:  243-block  0
    %%%%%:  243-block  1
       21:  243-block  2
        -:  244:      YY_ASSERT (sizeof (T) <= size);
       21:  245:      yytypeid_ = & typeid (T);
       42:  246:      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
       21:  246-block  0
       21:  246-block  1
       21:  246-block  2
    $$$$$:  246-block  3
        -:  247:    }
------------------
        -:  248:# else
        -:  249:    /// Instantiate an empty \a T in here.
        -:  250:    template <typename T>
        -:  251:    T&
        -:  252:    emplace ()
        -:  253:    {
        -:  254:      YY_ASSERT (!yytypeid_);
        -:  255:      YY_ASSERT (sizeof (T) <= size);
        -:  256:      yytypeid_ = & typeid (T);
        -:  257:      return *new (yyas_<T> ()) T ();
        -:  258:    }
        -:  259:
        -:  260:    /// Instantiate a \a T in here from \a t.
        -:  261:    template <typename T>
        -:  262:    T&
        -:  263:    emplace (const T& t)
        -:  264:    {
        -:  265:      YY_ASSERT (!yytypeid_);
        -:  266:      YY_ASSERT (sizeof (T) <= size);
        -:  267:      yytypeid_ = & typeid (T);
        -:  268:      return *new (yyas_<T> ()) T (t);
        -:  269:    }
        -:  270:# endif
        -:  271:
        -:  272:    /// Instantiate an empty \a T in here.
        -:  273:    /// Obsolete, use emplace.
        -:  274:    template <typename T>
        -:  275:    T&
        -:  276:    build ()
        -:  277:    {
        -:  278:      return emplace<T> ();
        -:  279:    }
        -:  280:
        -:  281:    /// Instantiate a \a T in here from \a t.
        -:  282:    /// Obsolete, use emplace.
        -:  283:    template <typename T>
        -:  284:    T&
        -:  285:    build (const T& t)
        -:  286:    {
        -:  287:      return emplace<T> (t);
        -:  288:    }
        -:  289:
        -:  290:    /// Accessor to a built \a T.
        -:  291:    template <typename T>
        -:  292:    T&
    1216*:  293:    as () YY_NOEXCEPT
        -:  294:    {
    1216*:  295:      YY_ASSERT (yytypeid_);
    1216*:  296:      YY_ASSERT (*yytypeid_ == typeid (T));
        -:  297:      YY_ASSERT (sizeof (T) <= size);
    1216*:  298:      return *yyas_<T> ();
        -:  299:    }
------------------
_ZN2yy6parser13semantic_type2asIdEERT_v:
    #####:  293:    as () YY_NOEXCEPT
        -:  294:    {
    #####:  295:      YY_ASSERT (yytypeid_);
    %%%%%:  295-block  0
    %%%%%:  295-block  1
    %%%%%:  295-block  2
    #####:  296:      YY_ASSERT (*yytypeid_ == typeid (T));
    %%%%%:  296-block  0
    %%%%%:  296-block  1
    %%%%%:  296-block  2
        -:  297:      YY_ASSERT (sizeof (T) <= size);
    #####:  298:      return *yyas_<T> ();
    %%%%%:  298-block  0
        -:  299:    }
------------------
_ZN2yy6parser13semantic_type2asIiEERT_v:
      136:  293:    as () YY_NOEXCEPT
        -:  294:    {
     136*:  295:      YY_ASSERT (yytypeid_);
      136:  295-block  0
    %%%%%:  295-block  1
      136:  295-block  2
     136*:  296:      YY_ASSERT (*yytypeid_ == typeid (T));
      136:  296-block  0
    %%%%%:  296-block  1
      136:  296-block  2
        -:  297:      YY_ASSERT (sizeof (T) <= size);
      136:  298:      return *yyas_<T> ();
      136:  298-block  0
        -:  299:    }
------------------
_ZN2yy6parser13semantic_type2asI4DestEERT_v:
      105:  293:    as () YY_NOEXCEPT
        -:  294:    {
     105*:  295:      YY_ASSERT (yytypeid_);
      105:  295-block  0
    %%%%%:  295-block  1
      105:  295-block  2
     105*:  296:      YY_ASSERT (*yytypeid_ == typeid (T));
      105:  296-block  0
    %%%%%:  296-block  1
      105:  296-block  2
        -:  297:      YY_ASSERT (sizeof (T) <= size);
      105:  298:      return *yyas_<T> ();
      105:  298-block  0
        -:  299:    }
------------------
_ZN2yy6parser13semantic_type2asI4QuadEERT_v:
      396:  293:    as () YY_NOEXCEPT
        -:  294:    {
     396*:  295:      YY_ASSERT (yytypeid_);
      396:  295-block  0
    %%%%%:  295-block  1
      396:  295-block  2
     396*:  296:      YY_ASSERT (*yytypeid_ == typeid (T));
      396:  296-block  0
    %%%%%:  296-block  1
      396:  296-block  2
        -:  297:      YY_ASSERT (sizeof (T) <= size);
      396:  298:      return *yyas_<T> ();
      396:  298-block  0
        -:  299:    }
------------------
_ZN2yy6parser13semantic_type2asINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEERT_v:
      579:  293:    as () YY_NOEXCEPT
        -:  294:    {
     579*:  295:      YY_ASSERT (yytypeid_);
      579:  295-block  0
    %%%%%:  295-block  1
      579:  295-block  2
     579*:  296:      YY_ASSERT (*yytypeid_ == typeid (T));
      579:  296-block  0
    %%%%%:  296-block  1
      579:  296-block  2
        -:  297:      YY_ASSERT (sizeof (T) <= size);
      579:  298:      return *yyas_<T> ();
      579:  298-block  0
        -:  299:    }
------------------
        -:  300:
        -:  301:    /// Const accessor to a built \a T (for %printer).
        -:  302:    template <typename T>
        -:  303:    const T&
        -:  304:    as () const YY_NOEXCEPT
        -:  305:    {
        -:  306:      YY_ASSERT (yytypeid_);
        -:  307:      YY_ASSERT (*yytypeid_ == typeid (T));
        -:  308:      YY_ASSERT (sizeof (T) <= size);
        -:  309:      return *yyas_<T> ();
        -:  310:    }
        -:  311:
        -:  312:    /// Swap the content with \a that, of same type.
        -:  313:    ///
        -:  314:    /// Both variants must be built beforehand, because swapping the actual
        -:  315:    /// data requires reading it (with as()), and this is not possible on
        -:  316:    /// unconstructed variants: it would require some dynamic testing, which
        -:  317:    /// should not be the variant's responsibility.
        -:  318:    /// Swapping between built and (possibly) non-built is done with
        -:  319:    /// self_type::move ().
        -:  320:    template <typename T>
        -:  321:    void
        -:  322:    swap (self_type& that) YY_NOEXCEPT
        -:  323:    {
        -:  324:      YY_ASSERT (yytypeid_);
        -:  325:      YY_ASSERT (*yytypeid_ == *that.yytypeid_);
        -:  326:      std::swap (as<T> (), that.as<T> ());
        -:  327:    }
        -:  328:
        -:  329:    /// Move the content of \a that to this.
        -:  330:    ///
        -:  331:    /// Destroys \a that.
        -:  332:    template <typename T>
        -:  333:    void
        -:  334:    move (self_type& that)
        -:  335:    {
        -:  336:# if 201103L <= YY_CPLUSPLUS
        -:  337:      emplace<T> (std::move (that.as<T> ()));
        -:  338:# else
        -:  339:      emplace<T> ();
        -:  340:      swap<T> (that);
        -:  341:# endif
        -:  342:      that.destroy<T> ();
        -:  343:    }
        -:  344:
        -:  345:# if 201103L <= YY_CPLUSPLUS
        -:  346:    /// Move the content of \a that to this.
        -:  347:    template <typename T>
        -:  348:    void
     329*:  349:    move (self_type&& that)
        -:  350:    {
     329*:  351:      emplace<T> (std::move (that.as<T> ()));
     329*:  352:      that.destroy<T> ();
     329*:  353:    }
------------------
_ZN2yy6parser13semantic_type4moveINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEvOS1_:
      183:  349:    move (self_type&& that)
        -:  350:    {
      183:  351:      emplace<T> (std::move (that.as<T> ()));
      183:  351-block  0
      183:  352:      that.destroy<T> ();
      183:  353:    }
------------------
_ZN2yy6parser13semantic_type4moveIiEEvOS1_:
       51:  349:    move (self_type&& that)
        -:  350:    {
       51:  351:      emplace<T> (std::move (that.as<T> ()));
       51:  351-block  0
       51:  352:      that.destroy<T> ();
       51:  353:    }
------------------
_ZN2yy6parser13semantic_type4moveIdEEvOS1_:
    #####:  349:    move (self_type&& that)
        -:  350:    {
    #####:  351:      emplace<T> (std::move (that.as<T> ()));
    %%%%%:  351-block  0
    #####:  352:      that.destroy<T> ();
    #####:  353:    }
------------------
_ZN2yy6parser13semantic_type4moveI4QuadEEvOS1_:
       74:  349:    move (self_type&& that)
        -:  350:    {
       74:  351:      emplace<T> (std::move (that.as<T> ()));
       74:  351-block  0
       74:  352:      that.destroy<T> ();
       74:  353:    }
------------------
_ZN2yy6parser13semantic_type4moveI4DestEEvOS1_:
       21:  349:    move (self_type&& that)
        -:  350:    {
       21:  351:      emplace<T> (std::move (that.as<T> ()));
       21:  351-block  0
       21:  352:      that.destroy<T> ();
       21:  353:    }
------------------
        -:  354:#endif
        -:  355:
        -:  356:    /// Copy the content of \a that to this.
        -:  357:    template <typename T>
        -:  358:    void
        -:  359:    copy (const self_type& that)
        -:  360:    {
        -:  361:      emplace<T> (that.as<T> ());
        -:  362:    }
        -:  363:
        -:  364:    /// Destroy the stored \a T.
        -:  365:    template <typename T>
        -:  366:    void
     528*:  367:    destroy ()
        -:  368:    {
     528*:  369:      as<T> ().~T ();
     528*:  370:      yytypeid_ = YY_NULLPTR;
     528*:  371:    }
------------------
_ZN2yy6parser13semantic_type7destroyINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEvv:
      270:  367:    destroy ()
        -:  368:    {
      270:  369:      as<T> ().~T ();
      270:  369-block  0
      270:  370:      yytypeid_ = YY_NULLPTR;
      270:  371:    }
------------------
_ZN2yy6parser13semantic_type7destroyIiEEvv:
       68:  367:    destroy ()
        -:  368:    {
       68:  369:      as<T> ().~T ();
       68:  369-block  0
       68:  370:      yytypeid_ = YY_NULLPTR;
       68:  371:    }
------------------
_ZN2yy6parser13semantic_type7destroyIdEEvv:
    #####:  367:    destroy ()
        -:  368:    {
    #####:  369:      as<T> ().~T ();
    %%%%%:  369-block  0
    #####:  370:      yytypeid_ = YY_NULLPTR;
    #####:  371:    }
------------------
_ZN2yy6parser13semantic_type7destroyI4QuadEEvv:
      148:  367:    destroy ()
        -:  368:    {
      148:  369:      as<T> ().~T ();
      148:  369-block  0
      148:  370:      yytypeid_ = YY_NULLPTR;
      148:  371:    }
------------------
_ZN2yy6parser13semantic_type7destroyI4DestEEvv:
       42:  367:    destroy ()
        -:  368:    {
       42:  369:      as<T> ().~T ();
       42:  369-block  0
       42:  370:      yytypeid_ = YY_NULLPTR;
       42:  371:    }
------------------
        -:  372:
        -:  373:  private:
        -:  374:#if YY_CPLUSPLUS < 201103L
        -:  375:    /// Non copyable.
        -:  376:    semantic_type (const self_type&);
        -:  377:    /// Non copyable.
        -:  378:    self_type& operator= (const self_type&);
        -:  379:#endif
        -:  380:
        -:  381:    /// Accessor to raw memory as \a T.
        -:  382:    template <typename T>
        -:  383:    T*
    1744*:  384:    yyas_ () YY_NOEXCEPT
        -:  385:    {
    1744*:  386:      void *yyp = yybuffer_.yyraw;
    1744*:  387:      return static_cast<T*> (yyp);
        -:  388:     }
------------------
_ZN2yy6parser13semantic_type5yyas_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEPT_v:
      849:  384:    yyas_ () YY_NOEXCEPT
        -:  385:    {
      849:  386:      void *yyp = yybuffer_.yyraw;
      849:  387:      return static_cast<T*> (yyp);
      849:  387-block  0
        -:  388:     }
------------------
_ZN2yy6parser13semantic_type5yyas_IiEEPT_v:
      204:  384:    yyas_ () YY_NOEXCEPT
        -:  385:    {
      204:  386:      void *yyp = yybuffer_.yyraw;
      204:  387:      return static_cast<T*> (yyp);
      204:  387-block  0
        -:  388:     }
------------------
_ZN2yy6parser13semantic_type5yyas_IdEEPT_v:
    #####:  384:    yyas_ () YY_NOEXCEPT
        -:  385:    {
    #####:  386:      void *yyp = yybuffer_.yyraw;
    #####:  387:      return static_cast<T*> (yyp);
    %%%%%:  387-block  0
        -:  388:     }
------------------
_ZN2yy6parser13semantic_type5yyas_I4QuadEEPT_v:
      544:  384:    yyas_ () YY_NOEXCEPT
        -:  385:    {
      544:  386:      void *yyp = yybuffer_.yyraw;
      544:  387:      return static_cast<T*> (yyp);
      544:  387-block  0
        -:  388:     }
------------------
_ZN2yy6parser13semantic_type5yyas_I4DestEEPT_v:
      147:  384:    yyas_ () YY_NOEXCEPT
        -:  385:    {
      147:  386:      void *yyp = yybuffer_.yyraw;
      147:  387:      return static_cast<T*> (yyp);
      147:  387-block  0
        -:  388:     }
------------------
        -:  389:
        -:  390:    /// Const accessor to raw memory as \a T.
        -:  391:    template <typename T>
        -:  392:    const T*
        -:  393:    yyas_ () const YY_NOEXCEPT
        -:  394:    {
        -:  395:      const void *yyp = yybuffer_.yyraw;
        -:  396:      return static_cast<const T*> (yyp);
        -:  397:     }
        -:  398:
        -:  399:    /// An auxiliary type to compute the largest semantic type.
        -:  400:    union union_type
        -:  401:    {
        -:  402:      // dest
        -:  403:      char dummy1[sizeof (Dest)];
        -:  404:
        -:  405:      // value
        -:  406:      // quadruple
        -:  407:      // if_statement
        -:  408:      // goto
        -:  409:      // assignment
        -:  410:      char dummy2[sizeof (Quad)];
        -:  411:
        -:  412:      // "float"
        -:  413:      char dummy3[sizeof (double)];
        -:  414:
        -:  415:      // "int"
        -:  416:      char dummy4[sizeof (int)];
        -:  417:
        -:  418:      // "identifier"
        -:  419:      // term
        -:  420:      // label
        -:  421:      char dummy5[sizeof (std::string)];
        -:  422:    };
        -:  423:
        -:  424:    /// The size of the largest semantic type.
        -:  425:    enum { size = sizeof (union_type) };
        -:  426:
        -:  427:    /// A buffer to store semantic values.
        -:  428:    union
        -:  429:    {
        -:  430:      /// Strongest alignment constraints.
        -:  431:      long double yyalign_me;
        -:  432:      /// A buffer large enough to store any of the semantic values.
        -:  433:      char yyraw[size];
        -:  434:    } yybuffer_;
        -:  435:
        -:  436:    /// Whether the content is built: if defined, the name of the stored type.
        -:  437:    const std::type_info *yytypeid_;
        -:  438:  };
        -:  439:
        -:  440:#else
        -:  441:    typedef YYSTYPE semantic_type;
        -:  442:#endif
        -:  443:    /// Symbol locations.
        -:  444:    typedef location location_type;
        -:  445:
        -:  446:    /// Syntax errors thrown from user actions.
        -:  447:    struct syntax_error : std::runtime_error
        -:  448:    {
        -:  449:      syntax_error (const location_type& l, const std::string& m)
        -:  450:        : std::runtime_error (m)
        -:  451:        , location (l)
        -:  452:      {}
        -:  453:
        -:  454:      syntax_error (const syntax_error& s)
        -:  455:        : std::runtime_error (s.what ())
        -:  456:        , location (s.location)
        -:  457:      {}
        -:  458:
        -:  459:      ~syntax_error () YY_NOEXCEPT YY_NOTHROW;
        -:  460:
        -:  461:      location_type location;
        -:  462:    };
        -:  463:
        -:  464:    /// Token kinds.
        -:  465:    struct token
        -:  466:    {
        -:  467:      enum token_kind_type
        -:  468:      {
        -:  469:        TOK_YYEMPTY = -2,
        -:  470:    TOK_YYEOF = 0,                 // "end of file"
        -:  471:    TOK_YYerror = 1,               // error
        -:  472:    TOK_YYUNDEF = 2,               // "invalid token"
        -:  473:    TOK_IFTRUE = 3,                // "if"
        -:  474:    TOK_IFFALSE = 4,               // "ifFalse"
        -:  475:    TOK_GOTO = 5,                  // "goto"
        -:  476:    TOK_HALT = 6,                  // "halt"
        -:  477:    TOK_CALL = 7,                  // "call"
        -:  478:    TOK_PARAM = 8,                 // "param"
        -:  479:    TOK_NOP = 9,                   // "nop"
        -:  480:    TOK_RETURN = 10,               // "return"
        -:  481:    TOK_NEWLINE = 11,              // "newline"
        -:  482:    TOK_ASSIGN = 12,               // "="
        -:  483:    TOK_PLUS = 13,                 // "+"
        -:  484:    TOK_MINUS = 14,                // "-"
        -:  485:    TOK_MULT = 15,                 // "*"
        -:  486:    TOK_DIV = 16,                  // "/"
        -:  487:    TOK_REF = 17,                  // "&"
        -:  488:    TOK_CMP_LT = 18,               // "<"
        -:  489:    TOK_CMP_GT = 19,               // ">"
        -:  490:    TOK_CMP_EQ = 20,               // "=="
        -:  491:    TOK_CMP_NEQ = 21,              // "!="
        -:  492:    TOK_LPAREN = 22,               // "("
        -:  493:    TOK_RPAREN = 23,               // ")"
        -:  494:    TOK_LBRACKET = 24,             // "["
        -:  495:    TOK_RBRACKET = 25,             // "]"
        -:  496:    TOK_SEMI = 26,                 // ";"
        -:  497:    TOK_COLON = 27,                // ":"
        -:  498:    TOK_IDENTIFIER = 28,           // "identifier"
        -:  499:    TOK_INT = 29,                  // "int"
        -:  500:    TOK_FLOAT = 30                 // "float"
        -:  501:      };
        -:  502:      /// Backward compatibility alias (Bison 3.6).
        -:  503:      typedef token_kind_type yytokentype;
        -:  504:    };
        -:  505:
        -:  506:    /// Token kind, as returned by yylex.
        -:  507:    typedef token::yytokentype token_kind_type;
        -:  508:
        -:  509:    /// Backward compatibility alias (Bison 3.6).
        -:  510:    typedef token_kind_type token_type;
        -:  511:
        -:  512:    /// Symbol kinds.
        -:  513:    struct symbol_kind
        -:  514:    {
        -:  515:      enum symbol_kind_type
        -:  516:      {
        -:  517:        YYNTOKENS = 31, ///< Number of tokens.
        -:  518:        S_YYEMPTY = -2,
        -:  519:        S_YYEOF = 0,                             // "end of file"
        -:  520:        S_YYerror = 1,                           // error
        -:  521:        S_YYUNDEF = 2,                           // "invalid token"
        -:  522:        S_IFTRUE = 3,                            // "if"
        -:  523:        S_IFFALSE = 4,                           // "ifFalse"
        -:  524:        S_GOTO = 5,                              // "goto"
        -:  525:        S_HALT = 6,                              // "halt"
        -:  526:        S_CALL = 7,                              // "call"
        -:  527:        S_PARAM = 8,                             // "param"
        -:  528:        S_NOP = 9,                               // "nop"
        -:  529:        S_RETURN = 10,                           // "return"
        -:  530:        S_NEWLINE = 11,                          // "newline"
        -:  531:        S_ASSIGN = 12,                           // "="
        -:  532:        S_PLUS = 13,                             // "+"
        -:  533:        S_MINUS = 14,                            // "-"
        -:  534:        S_MULT = 15,                             // "*"
        -:  535:        S_DIV = 16,                              // "/"
        -:  536:        S_REF = 17,                              // "&"
        -:  537:        S_CMP_LT = 18,                           // "<"
        -:  538:        S_CMP_GT = 19,                           // ">"
        -:  539:        S_CMP_EQ = 20,                           // "=="
        -:  540:        S_CMP_NEQ = 21,                          // "!="
        -:  541:        S_LPAREN = 22,                           // "("
        -:  542:        S_RPAREN = 23,                           // ")"
        -:  543:        S_LBRACKET = 24,                         // "["
        -:  544:        S_RBRACKET = 25,                         // "]"
        -:  545:        S_SEMI = 26,                             // ";"
        -:  546:        S_COLON = 27,                            // ":"
        -:  547:        S_IDENTIFIER = 28,                       // "identifier"
        -:  548:        S_INT = 29,                              // "int"
        -:  549:        S_FLOAT = 30,                            // "float"
        -:  550:        S_YYACCEPT = 31,                         // $accept
        -:  551:        S_dest = 32,                             // dest
        -:  552:        S_value = 33,                            // value
        -:  553:        S_quadruple = 34,                        // quadruple
        -:  554:        S_if_statement = 35,                     // if_statement
        -:  555:        S_goto = 36,                             // goto
        -:  556:        S_assignment = 37,                       // assignment
        -:  557:        S_term = 38,                             // term
        -:  558:        S_label = 39,                            // label
        -:  559:        S_stmts = 40,                            // stmts
        -:  560:        S_stmt = 41,                             // stmt
        -:  561:        S_mb_newline = 42,                       // mb_newline
        -:  562:        S_newlines = 43                          // newlines
        -:  563:      };
        -:  564:    };
        -:  565:
        -:  566:    /// (Internal) symbol kind.
        -:  567:    typedef symbol_kind::symbol_kind_type symbol_kind_type;
        -:  568:
        -:  569:    /// The number of tokens.
        -:  570:    static const symbol_kind_type YYNTOKENS = symbol_kind::YYNTOKENS;
        -:  571:
        -:  572:    /// A complete symbol.
        -:  573:    ///
        -:  574:    /// Expects its Base type to provide access to the symbol kind
        -:  575:    /// via kind ().
        -:  576:    ///
        -:  577:    /// Provide access to semantic value and location.
        -:  578:    template <typename Base>
        -:  579:    struct basic_symbol : Base
        -:  580:    {
        -:  581:      /// Alias to Base.
        -:  582:      typedef Base super_type;
        -:  583:
        -:  584:      /// Default constructor.
      838:  585:      basic_symbol ()
        -:  586:        : value ()
      838:  587:        , location ()
      838:  588:      {}
------------------
_ZN2yy6parser12basic_symbolINS0_8by_stateEEC2Ev:
      837:  585:      basic_symbol ()
        -:  586:        : value ()
      837:  587:        , location ()
      837:  587-block  0
      837:  588:      {}
------------------
_ZN2yy6parser12basic_symbolINS0_7by_kindEEC2Ev:
        1:  585:      basic_symbol ()
        -:  586:        : value ()
        1:  587:        , location ()
        1:  587-block  0
        1:  588:      {}
------------------
        -:  589:
        -:  590:#if 201103L <= YY_CPLUSPLUS
        -:  591:      /// Move constructor.
        -:  592:      basic_symbol (basic_symbol&& that)
        -:  593:        : Base (std::move (that))
        -:  594:        , value ()
        -:  595:        , location (std::move (that.location))
        -:  596:      {
        -:  597:        switch (this->kind ())
        -:  598:    {
        -:  599:      case symbol_kind::S_dest: // dest
        -:  600:        value.move< Dest > (std::move (that.value));
        -:  601:        break;
        -:  602:
        -:  603:      case symbol_kind::S_value: // value
        -:  604:      case symbol_kind::S_quadruple: // quadruple
        -:  605:      case symbol_kind::S_if_statement: // if_statement
        -:  606:      case symbol_kind::S_goto: // goto
        -:  607:      case symbol_kind::S_assignment: // assignment
        -:  608:        value.move< Quad > (std::move (that.value));
        -:  609:        break;
        -:  610:
        -:  611:      case symbol_kind::S_FLOAT: // "float"
        -:  612:        value.move< double > (std::move (that.value));
        -:  613:        break;
        -:  614:
        -:  615:      case symbol_kind::S_INT: // "int"
        -:  616:        value.move< int > (std::move (that.value));
        -:  617:        break;
        -:  618:
        -:  619:      case symbol_kind::S_IDENTIFIER: // "identifier"
        -:  620:      case symbol_kind::S_term: // term
        -:  621:      case symbol_kind::S_label: // label
        -:  622:        value.move< std::string > (std::move (that.value));
        -:  623:        break;
        -:  624:
        -:  625:      default:
        -:  626:        break;
        -:  627:    }
        -:  628:
        -:  629:      }
        -:  630:#endif
        -:  631:
        -:  632:      /// Copy constructor.
        -:  633:      basic_symbol (const basic_symbol& that);
        -:  634:
        -:  635:      /// Constructor for valueless symbols, and symbols from each type.
        -:  636:#if 201103L <= YY_CPLUSPLUS
      539:  637:      basic_symbol (typename Base::kind_type t, location_type&& l)
        -:  638:        : Base (t)
      539:  639:        , location (std::move (l))
      539:  639-block  0
      539:  640:      {}
        -:  641:#else
        -:  642:      basic_symbol (typename Base::kind_type t, const location_type& l)
        -:  643:        : Base (t)
        -:  644:        , location (l)
        -:  645:      {}
        -:  646:#endif
        -:  647:#if 201103L <= YY_CPLUSPLUS
        -:  648:      basic_symbol (typename Base::kind_type t, Dest&& v, location_type&& l)
        -:  649:        : Base (t)
        -:  650:        , value (std::move (v))
        -:  651:        , location (std::move (l))
        -:  652:      {}
        -:  653:#else
        -:  654:      basic_symbol (typename Base::kind_type t, const Dest& v, const location_type& l)
        -:  655:        : Base (t)
        -:  656:        , value (v)
        -:  657:        , location (l)
        -:  658:      {}
        -:  659:#endif
        -:  660:#if 201103L <= YY_CPLUSPLUS
        -:  661:      basic_symbol (typename Base::kind_type t, Quad&& v, location_type&& l)
        -:  662:        : Base (t)
        -:  663:        , value (std::move (v))
        -:  664:        , location (std::move (l))
        -:  665:      {}
        -:  666:#else
        -:  667:      basic_symbol (typename Base::kind_type t, const Quad& v, const location_type& l)
        -:  668:        : Base (t)
        -:  669:        , value (v)
        -:  670:        , location (l)
        -:  671:      {}
        -:  672:#endif
        -:  673:#if 201103L <= YY_CPLUSPLUS
        -:  674:      basic_symbol (typename Base::kind_type t, double&& v, location_type&& l)
        -:  675:        : Base (t)
        -:  676:        , value (std::move (v))
        -:  677:        , location (std::move (l))
        -:  678:      {}
        -:  679:#else
        -:  680:      basic_symbol (typename Base::kind_type t, const double& v, const location_type& l)
        -:  681:        : Base (t)
        -:  682:        , value (v)
        -:  683:        , location (l)
        -:  684:      {}
        -:  685:#endif
        -:  686:#if 201103L <= YY_CPLUSPLUS
        -:  687:      basic_symbol (typename Base::kind_type t, int&& v, location_type&& l)
        -:  688:        : Base (t)
        -:  689:        , value (std::move (v))
        -:  690:        , location (std::move (l))
        -:  691:      {}
        -:  692:#else
        -:  693:      basic_symbol (typename Base::kind_type t, const int& v, const location_type& l)
        -:  694:        : Base (t)
        -:  695:        , value (v)
        -:  696:        , location (l)
        -:  697:      {}
        -:  698:#endif
        -:  699:#if 201103L <= YY_CPLUSPLUS
        -:  700:      basic_symbol (typename Base::kind_type t, std::string&& v, location_type&& l)
        -:  701:        : Base (t)
        -:  702:        , value (std::move (v))
        -:  703:        , location (std::move (l))
        -:  704:      {}
        -:  705:#else
        -:  706:      basic_symbol (typename Base::kind_type t, const std::string& v, const location_type& l)
        -:  707:        : Base (t)
        -:  708:        , value (v)
        -:  709:        , location (l)
        -:  710:      {}
        -:  711:#endif
        -:  712:
        -:  713:      /// Destroy the symbol.
     1524:  714:      ~basic_symbol ()
        -:  715:      {
     1524:  716:        clear ();
     1524:  717:      }
------------------
_ZN2yy6parser12basic_symbolINS0_8by_stateEED2Ev:
     1376:  714:      ~basic_symbol ()
        -:  715:      {
     1376:  716:        clear ();
     1376:  716-block  0
     1376:  717:      }
------------------
_ZN2yy6parser12basic_symbolINS0_7by_kindEED2Ev:
      148:  714:      ~basic_symbol ()
        -:  715:      {
      148:  716:        clear ();
      148:  716-block  0
      148:  717:      }
------------------
        -:  718:
        -:  719:      /// Destroy contents, and record that is empty.
     1524:  720:      void clear ()
        -:  721:      {
        -:  722:        // User destructor.
     1524:  723:        symbol_kind_type yykind = this->kind ();
     1524:  724:        basic_symbol<Base>& yysym = *this;
        -:  725:        (void) yysym;
        -:  726:        switch (yykind)
        -:  727:        {
        -:  728:       default:
     1524:  729:          break;
        -:  730:        }
        -:  731:
        -:  732:        // Value type destructor.
     1524:  733:switch (yykind)
        -:  734:    {
      21*:  735:      case symbol_kind::S_dest: // dest
      21*:  736:        value.template destroy< Dest > ();
      21*:  737:        break;
        -:  738:
      74*:  739:      case symbol_kind::S_value: // value
        -:  740:      case symbol_kind::S_quadruple: // quadruple
        -:  741:      case symbol_kind::S_if_statement: // if_statement
        -:  742:      case symbol_kind::S_goto: // goto
        -:  743:      case symbol_kind::S_assignment: // assignment
      74*:  744:        value.template destroy< Quad > ();
      74*:  745:        break;
        -:  746:
    #####:  747:      case symbol_kind::S_FLOAT: // "float"
    #####:  748:        value.template destroy< double > ();
    #####:  749:        break;
        -:  750:
      17*:  751:      case symbol_kind::S_INT: // "int"
      17*:  752:        value.template destroy< int > ();
      17*:  753:        break;
        -:  754:
      87*:  755:      case symbol_kind::S_IDENTIFIER: // "identifier"
        -:  756:      case symbol_kind::S_term: // term
        -:  757:      case symbol_kind::S_label: // label
      87*:  758:        value.template destroy< std::string > ();
      87*:  759:        break;
        -:  760:
     1325:  761:      default:
     1325:  762:        break;
        -:  763:    }
        -:  764:
     1524:  765:        Base::clear ();
     1524:  766:      }
------------------
_ZN2yy6parser12basic_symbolINS0_8by_stateEE5clearEv:
     1376:  720:      void clear ()
        -:  721:      {
        -:  722:        // User destructor.
     1376:  723:        symbol_kind_type yykind = this->kind ();
     1376:  723-block  0
     1376:  724:        basic_symbol<Base>& yysym = *this;
        -:  725:        (void) yysym;
        -:  726:        switch (yykind)
        -:  727:        {
        -:  728:       default:
     1376:  729:          break;
        -:  730:        }
        -:  731:
        -:  732:        // Value type destructor.
     1376:  733:switch (yykind)
     1376:  733-block  0
        -:  734:    {
       21:  735:      case symbol_kind::S_dest: // dest
       21:  736:        value.template destroy< Dest > ();
       21:  736-block  0
       21:  737:        break;
        -:  738:
       74:  739:      case symbol_kind::S_value: // value
        -:  740:      case symbol_kind::S_quadruple: // quadruple
        -:  741:      case symbol_kind::S_if_statement: // if_statement
        -:  742:      case symbol_kind::S_goto: // goto
        -:  743:      case symbol_kind::S_assignment: // assignment
       74:  744:        value.template destroy< Quad > ();
       74:  744-block  0
       74:  745:        break;
        -:  746:
    #####:  747:      case symbol_kind::S_FLOAT: // "float"
    #####:  748:        value.template destroy< double > ();
    %%%%%:  748-block  0
    #####:  749:        break;
        -:  750:
       17:  751:      case symbol_kind::S_INT: // "int"
       17:  752:        value.template destroy< int > ();
       17:  752-block  0
       17:  753:        break;
        -:  754:
       87:  755:      case symbol_kind::S_IDENTIFIER: // "identifier"
        -:  756:      case symbol_kind::S_term: // term
        -:  757:      case symbol_kind::S_label: // label
       87:  758:        value.template destroy< std::string > ();
       87:  758-block  0
       87:  759:        break;
        -:  760:
     1177:  761:      default:
     1177:  762:        break;
     1177:  762-block  0
        -:  763:    }
        -:  764:
     1376:  765:        Base::clear ();
     1376:  765-block  0
     1376:  766:      }
------------------
_ZN2yy6parser12basic_symbolINS0_7by_kindEE5clearEv:
      148:  720:      void clear ()
        -:  721:      {
        -:  722:        // User destructor.
      148:  723:        symbol_kind_type yykind = this->kind ();
      148:  723-block  0
      148:  724:        basic_symbol<Base>& yysym = *this;
        -:  725:        (void) yysym;
        -:  726:        switch (yykind)
        -:  727:        {
        -:  728:       default:
      148:  729:          break;
        -:  730:        }
        -:  731:
        -:  732:        // Value type destructor.
      148:  733:switch (yykind)
      148:  733-block  0
        -:  734:    {
    #####:  735:      case symbol_kind::S_dest: // dest
    #####:  736:        value.template destroy< Dest > ();
    %%%%%:  736-block  0
    #####:  737:        break;
        -:  738:
    #####:  739:      case symbol_kind::S_value: // value
        -:  740:      case symbol_kind::S_quadruple: // quadruple
        -:  741:      case symbol_kind::S_if_statement: // if_statement
        -:  742:      case symbol_kind::S_goto: // goto
        -:  743:      case symbol_kind::S_assignment: // assignment
    #####:  744:        value.template destroy< Quad > ();
    %%%%%:  744-block  0
    #####:  745:        break;
        -:  746:
    #####:  747:      case symbol_kind::S_FLOAT: // "float"
    #####:  748:        value.template destroy< double > ();
    %%%%%:  748-block  0
    #####:  749:        break;
        -:  750:
    #####:  751:      case symbol_kind::S_INT: // "int"
    #####:  752:        value.template destroy< int > ();
    %%%%%:  752-block  0
    #####:  753:        break;
        -:  754:
    #####:  755:      case symbol_kind::S_IDENTIFIER: // "identifier"
        -:  756:      case symbol_kind::S_term: // term
        -:  757:      case symbol_kind::S_label: // label
    #####:  758:        value.template destroy< std::string > ();
    %%%%%:  758-block  0
    #####:  759:        break;
        -:  760:
      148:  761:      default:
      148:  762:        break;
      148:  762-block  0
        -:  763:    }
        -:  764:
      148:  765:        Base::clear ();
      148:  765-block  0
      148:  766:      }
------------------
        -:  767:
        -:  768:      /// The user-facing name of this symbol.
    #####:  769:      const char *name () const YY_NOEXCEPT
        -:  770:      {
    #####:  771:        return parser::symbol_name (this->kind ());
        -:  772:      }
------------------
_ZNK2yy6parser12basic_symbolINS0_7by_kindEE4nameEv:
    #####:  769:      const char *name () const YY_NOEXCEPT
        -:  770:      {
    #####:  771:        return parser::symbol_name (this->kind ());
    %%%%%:  771-block  0
        -:  772:      }
------------------
_ZNK2yy6parser12basic_symbolINS0_8by_stateEE4nameEv:
    #####:  769:      const char *name () const YY_NOEXCEPT
        -:  770:      {
    #####:  771:        return parser::symbol_name (this->kind ());
    %%%%%:  771-block  0
        -:  772:      }
------------------
        -:  773:
        -:  774:      /// Backward compatibility (Bison 3.6).
        -:  775:      symbol_kind_type type_get () const YY_NOEXCEPT;
        -:  776:
        -:  777:      /// Whether empty.
        -:  778:      bool empty () const YY_NOEXCEPT;
        -:  779:
        -:  780:      /// Destructive move, \a s is emptied into this.
        -:  781:      void move (basic_symbol& s);
        -:  782:
        -:  783:      /// The semantic value.
        -:  784:      semantic_type value;
        -:  785:
        -:  786:      /// The location.
        -:  787:      location_type location;
        -:  788:
        -:  789:    private:
        -:  790:#if YY_CPLUSPLUS < 201103L
        -:  791:      /// Assignment operator.
        -:  792:      basic_symbol& operator= (const basic_symbol& that);
        -:  793:#endif
        -:  794:    };
        -:  795:
        -:  796:    /// Type access provider for token (enum) based symbols.
        -:  797:    struct by_kind
        -:  798:    {
        -:  799:      /// Default constructor.
        -:  800:      by_kind ();
        -:  801:
        -:  802:#if 201103L <= YY_CPLUSPLUS
        -:  803:      /// Move constructor.
        -:  804:      by_kind (by_kind&& that);
        -:  805:#endif
        -:  806:
        -:  807:      /// Copy constructor.
        -:  808:      by_kind (const by_kind& that);
        -:  809:
        -:  810:      /// The symbol kind as needed by the constructor.
        -:  811:      typedef token_kind_type kind_type;
        -:  812:
        -:  813:      /// Constructor from (external) token numbers.
        -:  814:      by_kind (kind_type t);
        -:  815:
        -:  816:      /// Record that this symbol is empty.
        -:  817:      void clear ();
        -:  818:
        -:  819:      /// Steal the symbol kind from \a that.
        -:  820:      void move (by_kind& that);
        -:  821:
        -:  822:      /// The (internal) type number (corresponding to \a type).
        -:  823:      /// \a empty when empty.
        -:  824:      symbol_kind_type kind () const YY_NOEXCEPT;
        -:  825:
        -:  826:      /// Backward compatibility (Bison 3.6).
        -:  827:      symbol_kind_type type_get () const YY_NOEXCEPT;
        -:  828:
        -:  829:      /// The symbol kind.
        -:  830:      /// \a S_YYEMPTY when empty.
        -:  831:      symbol_kind_type kind_;
        -:  832:    };
        -:  833:
        -:  834:    /// Backward compatibility for a private implementation detail (Bison 3.6).
        -:  835:    typedef by_kind by_type;
        -:  836:
        -:  837:    /// "External" symbols: returned by the scanner.
        -:  838:    struct symbol_type : basic_symbol<by_kind>
        -:  839:    {
        -:  840:      /// Superclass.
        -:  841:      typedef basic_symbol<by_kind> super_type;
        -:  842:
        -:  843:      /// Empty symbol.
        1:  844:      symbol_type () {}
        1:  844-block  0
        -:  845:
        -:  846:      /// Constructor for valueless symbols, and symbols from each type.
        -:  847:#if 201103L <= YY_CPLUSPLUS
        -:  848:      symbol_type (int tok, location_type l)
        -:  849:        : super_type(token_type (tok), std::move (l))
        -:  850:      {
        -:  851:        YY_ASSERT (tok == token::TOK_YYEOF || tok == token::TOK_YYerror || tok == token::TOK_YYUNDEF || tok == token::TOK_IFTRUE || tok == token::TOK_IFFALSE || tok == token::TOK_GOTO || tok == token::TOK_HALT || tok == token::TOK_CALL || tok == token::TOK_PARAM || tok == token::TOK_NOP || tok == token::TOK_RETURN || tok == token::TOK_NEWLINE || tok == token::TOK_ASSIGN || tok == token::TOK_PLUS || tok == token::TOK_MINUS || tok == token::TOK_MULT || tok == token::TOK_DIV || tok == token::TOK_REF || tok == token::TOK_CMP_LT || tok == token::TOK_CMP_GT || tok == token::TOK_CMP_EQ || tok == token::TOK_CMP_NEQ || tok == token::TOK_LPAREN || tok == token::TOK_RPAREN || tok == token::TOK_LBRACKET || tok == token::TOK_RBRACKET || tok == token::TOK_SEMI || tok == token::TOK_COLON);
        -:  852:      }
        -:  853:#else
        -:  854:      symbol_type (int tok, const location_type& l)
        -:  855:        : super_type(token_type (tok), l)
        -:  856:      {
        -:  857:        YY_ASSERT (tok == token::TOK_YYEOF || tok == token::TOK_YYerror || tok == token::TOK_YYUNDEF || tok == token::TOK_IFTRUE || tok == token::TOK_IFFALSE || tok == token::TOK_GOTO || tok == token::TOK_HALT || tok == token::TOK_CALL || tok == token::TOK_PARAM || tok == token::TOK_NOP || tok == token::TOK_RETURN || tok == token::TOK_NEWLINE || tok == token::TOK_ASSIGN || tok == token::TOK_PLUS || tok == token::TOK_MINUS || tok == token::TOK_MULT || tok == token::TOK_DIV || tok == token::TOK_REF || tok == token::TOK_CMP_LT || tok == token::TOK_CMP_GT || tok == token::TOK_CMP_EQ || tok == token::TOK_CMP_NEQ || tok == token::TOK_LPAREN || tok == token::TOK_RPAREN || tok == token::TOK_LBRACKET || tok == token::TOK_RBRACKET || tok == token::TOK_SEMI || tok == token::TOK_COLON);
        -:  858:      }
        -:  859:#endif
        -:  860:#if 201103L <= YY_CPLUSPLUS
        -:  861:      symbol_type (int tok, double v, location_type l)
        -:  862:        : super_type(token_type (tok), std::move (v), std::move (l))
        -:  863:      {
        -:  864:        YY_ASSERT (tok == token::TOK_FLOAT);
        -:  865:      }
        -:  866:#else
        -:  867:      symbol_type (int tok, const double& v, const location_type& l)
        -:  868:        : super_type(token_type (tok), v, l)
        -:  869:      {
        -:  870:        YY_ASSERT (tok == token::TOK_FLOAT);
        -:  871:      }
        -:  872:#endif
        -:  873:#if 201103L <= YY_CPLUSPLUS
        -:  874:      symbol_type (int tok, int v, location_type l)
        -:  875:        : super_type(token_type (tok), std::move (v), std::move (l))
        -:  876:      {
        -:  877:        YY_ASSERT (tok == token::TOK_INT);
        -:  878:      }
        -:  879:#else
        -:  880:      symbol_type (int tok, const int& v, const location_type& l)
        -:  881:        : super_type(token_type (tok), v, l)
        -:  882:      {
        -:  883:        YY_ASSERT (tok == token::TOK_INT);
        -:  884:      }
        -:  885:#endif
        -:  886:#if 201103L <= YY_CPLUSPLUS
        -:  887:      symbol_type (int tok, std::string v, location_type l)
        -:  888:        : super_type(token_type (tok), std::move (v), std::move (l))
        -:  889:      {
        -:  890:        YY_ASSERT (tok == token::TOK_IDENTIFIER);
        -:  891:      }
        -:  892:#else
        -:  893:      symbol_type (int tok, const std::string& v, const location_type& l)
        -:  894:        : super_type(token_type (tok), v, l)
        -:  895:      {
        -:  896:        YY_ASSERT (tok == token::TOK_IDENTIFIER);
        -:  897:      }
        -:  898:#endif
        -:  899:    };
        -:  900:
        -:  901:    /// Build a parser object.
        -:  902:    parser (driver& drv_yyarg);
        -:  903:    virtual ~parser ();
        -:  904:
        -:  905:#if 201103L <= YY_CPLUSPLUS
        -:  906:    /// Non copyable.
        -:  907:    parser (const parser&) = delete;
        -:  908:    /// Non copyable.
        -:  909:    parser& operator= (const parser&) = delete;
        -:  910:#endif
        -:  911:
        -:  912:    /// Parse.  An alias for parse ().
        -:  913:    /// \returns  0 iff parsing succeeded.
        -:  914:    int operator() ();
        -:  915:
        -:  916:    /// Parse.
        -:  917:    /// \returns  0 iff parsing succeeded.
        -:  918:    virtual int parse ();
        -:  919:
        -:  920:#if YYDEBUG
        -:  921:    /// The current debugging stream.
        -:  922:    std::ostream& debug_stream () const YY_ATTRIBUTE_PURE;
        -:  923:    /// Set the current debugging stream.
        -:  924:    void set_debug_stream (std::ostream &);
        -:  925:
        -:  926:    /// Type for debugging levels.
        -:  927:    typedef int debug_level_type;
        -:  928:    /// The current debugging level.
        -:  929:    debug_level_type debug_level () const YY_ATTRIBUTE_PURE;
        -:  930:    /// Set the current debugging level.
        -:  931:    void set_debug_level (debug_level_type l);
        -:  932:#endif
        -:  933:
        -:  934:    /// Report a syntax error.
        -:  935:    /// \param loc    where the syntax error is found.
        -:  936:    /// \param msg    a description of the syntax error.
        -:  937:    virtual void error (const location_type& loc, const std::string& msg);
        -:  938:
        -:  939:    /// Report a syntax error.
        -:  940:    void error (const syntax_error& err);
        -:  941:
        -:  942:    /// The user-facing name of the symbol whose (internal) number is
        -:  943:    /// YYSYMBOL.  No bounds checking.
        -:  944:    static const char *symbol_name (symbol_kind_type yysymbol);
        -:  945:
        -:  946:    // Implementation of make_symbol for each symbol type.
        -:  947:#if 201103L <= YY_CPLUSPLUS
        -:  948:      static
        -:  949:      symbol_type
        -:  950:      make_YYEOF (location_type l)
        -:  951:      {
        -:  952:        return symbol_type (token::TOK_YYEOF, std::move (l));
        -:  953:      }
        -:  954:#else
        -:  955:      static
        -:  956:      symbol_type
        -:  957:      make_YYEOF (const location_type& l)
        -:  958:      {
        -:  959:        return symbol_type (token::TOK_YYEOF, l);
        -:  960:      }
        -:  961:#endif
        -:  962:#if 201103L <= YY_CPLUSPLUS
        -:  963:      static
        -:  964:      symbol_type
        -:  965:      make_YYerror (location_type l)
        -:  966:      {
        -:  967:        return symbol_type (token::TOK_YYerror, std::move (l));
        -:  968:      }
        -:  969:#else
        -:  970:      static
        -:  971:      symbol_type
        -:  972:      make_YYerror (const location_type& l)
        -:  973:      {
        -:  974:        return symbol_type (token::TOK_YYerror, l);
        -:  975:      }
        -:  976:#endif
        -:  977:#if 201103L <= YY_CPLUSPLUS
        -:  978:      static
        -:  979:      symbol_type
        -:  980:      make_YYUNDEF (location_type l)
        -:  981:      {
        -:  982:        return symbol_type (token::TOK_YYUNDEF, std::move (l));
        -:  983:      }
        -:  984:#else
        -:  985:      static
        -:  986:      symbol_type
        -:  987:      make_YYUNDEF (const location_type& l)
        -:  988:      {
        -:  989:        return symbol_type (token::TOK_YYUNDEF, l);
        -:  990:      }
        -:  991:#endif
        -:  992:#if 201103L <= YY_CPLUSPLUS
        -:  993:      static
        -:  994:      symbol_type
        -:  995:      make_IFTRUE (location_type l)
        -:  996:      {
        -:  997:        return symbol_type (token::TOK_IFTRUE, std::move (l));
        -:  998:      }
        -:  999:#else
        -: 1000:      static
        -: 1001:      symbol_type
        -: 1002:      make_IFTRUE (const location_type& l)
        -: 1003:      {
        -: 1004:        return symbol_type (token::TOK_IFTRUE, l);
        -: 1005:      }
        -: 1006:#endif
        -: 1007:#if 201103L <= YY_CPLUSPLUS
        -: 1008:      static
        -: 1009:      symbol_type
        -: 1010:      make_IFFALSE (location_type l)
        -: 1011:      {
        -: 1012:        return symbol_type (token::TOK_IFFALSE, std::move (l));
        -: 1013:      }
        -: 1014:#else
        -: 1015:      static
        -: 1016:      symbol_type
        -: 1017:      make_IFFALSE (const location_type& l)
        -: 1018:      {
        -: 1019:        return symbol_type (token::TOK_IFFALSE, l);
        -: 1020:      }
        -: 1021:#endif
        -: 1022:#if 201103L <= YY_CPLUSPLUS
        -: 1023:      static
        -: 1024:      symbol_type
        -: 1025:      make_GOTO (location_type l)
        -: 1026:      {
        -: 1027:        return symbol_type (token::TOK_GOTO, std::move (l));
        -: 1028:      }
        -: 1029:#else
        -: 1030:      static
        -: 1031:      symbol_type
        -: 1032:      make_GOTO (const location_type& l)
        -: 1033:      {
        -: 1034:        return symbol_type (token::TOK_GOTO, l);
        -: 1035:      }
        -: 1036:#endif
        -: 1037:#if 201103L <= YY_CPLUSPLUS
        -: 1038:      static
        -: 1039:      symbol_type
        -: 1040:      make_HALT (location_type l)
        -: 1041:      {
        -: 1042:        return symbol_type (token::TOK_HALT, std::move (l));
        -: 1043:      }
        -: 1044:#else
        -: 1045:      static
        -: 1046:      symbol_type
        -: 1047:      make_HALT (const location_type& l)
        -: 1048:      {
        -: 1049:        return symbol_type (token::TOK_HALT, l);
        -: 1050:      }
        -: 1051:#endif
        -: 1052:#if 201103L <= YY_CPLUSPLUS
        -: 1053:      static
        -: 1054:      symbol_type
        -: 1055:      make_CALL (location_type l)
        -: 1056:      {
        -: 1057:        return symbol_type (token::TOK_CALL, std::move (l));
        -: 1058:      }
        -: 1059:#else
        -: 1060:      static
        -: 1061:      symbol_type
        -: 1062:      make_CALL (const location_type& l)
        -: 1063:      {
        -: 1064:        return symbol_type (token::TOK_CALL, l);
        -: 1065:      }
        -: 1066:#endif
        -: 1067:#if 201103L <= YY_CPLUSPLUS
        -: 1068:      static
        -: 1069:      symbol_type
        -: 1070:      make_PARAM (location_type l)
        -: 1071:      {
        -: 1072:        return symbol_type (token::TOK_PARAM, std::move (l));
        -: 1073:      }
        -: 1074:#else
        -: 1075:      static
        -: 1076:      symbol_type
        -: 1077:      make_PARAM (const location_type& l)
        -: 1078:      {
        -: 1079:        return symbol_type (token::TOK_PARAM, l);
        -: 1080:      }
        -: 1081:#endif
        -: 1082:#if 201103L <= YY_CPLUSPLUS
        -: 1083:      static
        -: 1084:      symbol_type
        -: 1085:      make_NOP (location_type l)
        -: 1086:      {
        -: 1087:        return symbol_type (token::TOK_NOP, std::move (l));
        -: 1088:      }
        -: 1089:#else
        -: 1090:      static
        -: 1091:      symbol_type
        -: 1092:      make_NOP (const location_type& l)
        -: 1093:      {
        -: 1094:        return symbol_type (token::TOK_NOP, l);
        -: 1095:      }
        -: 1096:#endif
        -: 1097:#if 201103L <= YY_CPLUSPLUS
        -: 1098:      static
        -: 1099:      symbol_type
        -: 1100:      make_RETURN (location_type l)
        -: 1101:      {
        -: 1102:        return symbol_type (token::TOK_RETURN, std::move (l));
        -: 1103:      }
        -: 1104:#else
        -: 1105:      static
        -: 1106:      symbol_type
        -: 1107:      make_RETURN (const location_type& l)
        -: 1108:      {
        -: 1109:        return symbol_type (token::TOK_RETURN, l);
        -: 1110:      }
        -: 1111:#endif
        -: 1112:#if 201103L <= YY_CPLUSPLUS
        -: 1113:      static
        -: 1114:      symbol_type
        -: 1115:      make_NEWLINE (location_type l)
        -: 1116:      {
        -: 1117:        return symbol_type (token::TOK_NEWLINE, std::move (l));
        -: 1118:      }
        -: 1119:#else
        -: 1120:      static
        -: 1121:      symbol_type
        -: 1122:      make_NEWLINE (const location_type& l)
        -: 1123:      {
        -: 1124:        return symbol_type (token::TOK_NEWLINE, l);
        -: 1125:      }
        -: 1126:#endif
        -: 1127:#if 201103L <= YY_CPLUSPLUS
        -: 1128:      static
        -: 1129:      symbol_type
        -: 1130:      make_ASSIGN (location_type l)
        -: 1131:      {
        -: 1132:        return symbol_type (token::TOK_ASSIGN, std::move (l));
        -: 1133:      }
        -: 1134:#else
        -: 1135:      static
        -: 1136:      symbol_type
        -: 1137:      make_ASSIGN (const location_type& l)
        -: 1138:      {
        -: 1139:        return symbol_type (token::TOK_ASSIGN, l);
        -: 1140:      }
        -: 1141:#endif
        -: 1142:#if 201103L <= YY_CPLUSPLUS
        -: 1143:      static
        -: 1144:      symbol_type
        -: 1145:      make_PLUS (location_type l)
        -: 1146:      {
        -: 1147:        return symbol_type (token::TOK_PLUS, std::move (l));
        -: 1148:      }
        -: 1149:#else
        -: 1150:      static
        -: 1151:      symbol_type
        -: 1152:      make_PLUS (const location_type& l)
        -: 1153:      {
        -: 1154:        return symbol_type (token::TOK_PLUS, l);
        -: 1155:      }
        -: 1156:#endif
        -: 1157:#if 201103L <= YY_CPLUSPLUS
        -: 1158:      static
        -: 1159:      symbol_type
        -: 1160:      make_MINUS (location_type l)
        -: 1161:      {
        -: 1162:        return symbol_type (token::TOK_MINUS, std::move (l));
        -: 1163:      }
        -: 1164:#else
        -: 1165:      static
        -: 1166:      symbol_type
        -: 1167:      make_MINUS (const location_type& l)
        -: 1168:      {
        -: 1169:        return symbol_type (token::TOK_MINUS, l);
        -: 1170:      }
        -: 1171:#endif
        -: 1172:#if 201103L <= YY_CPLUSPLUS
        -: 1173:      static
        -: 1174:      symbol_type
        -: 1175:      make_MULT (location_type l)
        -: 1176:      {
        -: 1177:        return symbol_type (token::TOK_MULT, std::move (l));
        -: 1178:      }
        -: 1179:#else
        -: 1180:      static
        -: 1181:      symbol_type
        -: 1182:      make_MULT (const location_type& l)
        -: 1183:      {
        -: 1184:        return symbol_type (token::TOK_MULT, l);
        -: 1185:      }
        -: 1186:#endif
        -: 1187:#if 201103L <= YY_CPLUSPLUS
        -: 1188:      static
        -: 1189:      symbol_type
        -: 1190:      make_DIV (location_type l)
        -: 1191:      {
        -: 1192:        return symbol_type (token::TOK_DIV, std::move (l));
        -: 1193:      }
        -: 1194:#else
        -: 1195:      static
        -: 1196:      symbol_type
        -: 1197:      make_DIV (const location_type& l)
        -: 1198:      {
        -: 1199:        return symbol_type (token::TOK_DIV, l);
        -: 1200:      }
        -: 1201:#endif
        -: 1202:#if 201103L <= YY_CPLUSPLUS
        -: 1203:      static
        -: 1204:      symbol_type
        -: 1205:      make_REF (location_type l)
        -: 1206:      {
        -: 1207:        return symbol_type (token::TOK_REF, std::move (l));
        -: 1208:      }
        -: 1209:#else
        -: 1210:      static
        -: 1211:      symbol_type
        -: 1212:      make_REF (const location_type& l)
        -: 1213:      {
        -: 1214:        return symbol_type (token::TOK_REF, l);
        -: 1215:      }
        -: 1216:#endif
        -: 1217:#if 201103L <= YY_CPLUSPLUS
        -: 1218:      static
        -: 1219:      symbol_type
        -: 1220:      make_CMP_LT (location_type l)
        -: 1221:      {
        -: 1222:        return symbol_type (token::TOK_CMP_LT, std::move (l));
        -: 1223:      }
        -: 1224:#else
        -: 1225:      static
        -: 1226:      symbol_type
        -: 1227:      make_CMP_LT (const location_type& l)
        -: 1228:      {
        -: 1229:        return symbol_type (token::TOK_CMP_LT, l);
        -: 1230:      }
        -: 1231:#endif
        -: 1232:#if 201103L <= YY_CPLUSPLUS
        -: 1233:      static
        -: 1234:      symbol_type
        -: 1235:      make_CMP_GT (location_type l)
        -: 1236:      {
        -: 1237:        return symbol_type (token::TOK_CMP_GT, std::move (l));
        -: 1238:      }
        -: 1239:#else
        -: 1240:      static
        -: 1241:      symbol_type
        -: 1242:      make_CMP_GT (const location_type& l)
        -: 1243:      {
        -: 1244:        return symbol_type (token::TOK_CMP_GT, l);
        -: 1245:      }
        -: 1246:#endif
        -: 1247:#if 201103L <= YY_CPLUSPLUS
        -: 1248:      static
        -: 1249:      symbol_type
        -: 1250:      make_CMP_EQ (location_type l)
        -: 1251:      {
        -: 1252:        return symbol_type (token::TOK_CMP_EQ, std::move (l));
        -: 1253:      }
        -: 1254:#else
        -: 1255:      static
        -: 1256:      symbol_type
        -: 1257:      make_CMP_EQ (const location_type& l)
        -: 1258:      {
        -: 1259:        return symbol_type (token::TOK_CMP_EQ, l);
        -: 1260:      }
        -: 1261:#endif
        -: 1262:#if 201103L <= YY_CPLUSPLUS
        -: 1263:      static
        -: 1264:      symbol_type
        -: 1265:      make_CMP_NEQ (location_type l)
        -: 1266:      {
        -: 1267:        return symbol_type (token::TOK_CMP_NEQ, std::move (l));
        -: 1268:      }
        -: 1269:#else
        -: 1270:      static
        -: 1271:      symbol_type
        -: 1272:      make_CMP_NEQ (const location_type& l)
        -: 1273:      {
        -: 1274:        return symbol_type (token::TOK_CMP_NEQ, l);
        -: 1275:      }
        -: 1276:#endif
        -: 1277:#if 201103L <= YY_CPLUSPLUS
        -: 1278:      static
        -: 1279:      symbol_type
        -: 1280:      make_LPAREN (location_type l)
        -: 1281:      {
        -: 1282:        return symbol_type (token::TOK_LPAREN, std::move (l));
        -: 1283:      }
        -: 1284:#else
        -: 1285:      static
        -: 1286:      symbol_type
        -: 1287:      make_LPAREN (const location_type& l)
        -: 1288:      {
        -: 1289:        return symbol_type (token::TOK_LPAREN, l);
        -: 1290:      }
        -: 1291:#endif
        -: 1292:#if 201103L <= YY_CPLUSPLUS
        -: 1293:      static
        -: 1294:      symbol_type
        -: 1295:      make_RPAREN (location_type l)
        -: 1296:      {
        -: 1297:        return symbol_type (token::TOK_RPAREN, std::move (l));
        -: 1298:      }
        -: 1299:#else
        -: 1300:      static
        -: 1301:      symbol_type
        -: 1302:      make_RPAREN (const location_type& l)
        -: 1303:      {
        -: 1304:        return symbol_type (token::TOK_RPAREN, l);
        -: 1305:      }
        -: 1306:#endif
        -: 1307:#if 201103L <= YY_CPLUSPLUS
        -: 1308:      static
        -: 1309:      symbol_type
        -: 1310:      make_LBRACKET (location_type l)
        -: 1311:      {
        -: 1312:        return symbol_type (token::TOK_LBRACKET, std::move (l));
        -: 1313:      }
        -: 1314:#else
        -: 1315:      static
        -: 1316:      symbol_type
        -: 1317:      make_LBRACKET (const location_type& l)
        -: 1318:      {
        -: 1319:        return symbol_type (token::TOK_LBRACKET, l);
        -: 1320:      }
        -: 1321:#endif
        -: 1322:#if 201103L <= YY_CPLUSPLUS
        -: 1323:      static
        -: 1324:      symbol_type
        -: 1325:      make_RBRACKET (location_type l)
        -: 1326:      {
        -: 1327:        return symbol_type (token::TOK_RBRACKET, std::move (l));
        -: 1328:      }
        -: 1329:#else
        -: 1330:      static
        -: 1331:      symbol_type
        -: 1332:      make_RBRACKET (const location_type& l)
        -: 1333:      {
        -: 1334:        return symbol_type (token::TOK_RBRACKET, l);
        -: 1335:      }
        -: 1336:#endif
        -: 1337:#if 201103L <= YY_CPLUSPLUS
        -: 1338:      static
        -: 1339:      symbol_type
        -: 1340:      make_SEMI (location_type l)
        -: 1341:      {
        -: 1342:        return symbol_type (token::TOK_SEMI, std::move (l));
        -: 1343:      }
        -: 1344:#else
        -: 1345:      static
        -: 1346:      symbol_type
        -: 1347:      make_SEMI (const location_type& l)
        -: 1348:      {
        -: 1349:        return symbol_type (token::TOK_SEMI, l);
        -: 1350:      }
        -: 1351:#endif
        -: 1352:#if 201103L <= YY_CPLUSPLUS
        -: 1353:      static
        -: 1354:      symbol_type
        -: 1355:      make_COLON (location_type l)
        -: 1356:      {
        -: 1357:        return symbol_type (token::TOK_COLON, std::move (l));
        -: 1358:      }
        -: 1359:#else
        -: 1360:      static
        -: 1361:      symbol_type
        -: 1362:      make_COLON (const location_type& l)
        -: 1363:      {
        -: 1364:        return symbol_type (token::TOK_COLON, l);
        -: 1365:      }
        -: 1366:#endif
        -: 1367:#if 201103L <= YY_CPLUSPLUS
        -: 1368:      static
        -: 1369:      symbol_type
        -: 1370:      make_IDENTIFIER (std::string v, location_type l)
        -: 1371:      {
        -: 1372:        return symbol_type (token::TOK_IDENTIFIER, std::move (v), std::move (l));
        -: 1373:      }
        -: 1374:#else
        -: 1375:      static
        -: 1376:      symbol_type
        -: 1377:      make_IDENTIFIER (const std::string& v, const location_type& l)
        -: 1378:      {
        -: 1379:        return symbol_type (token::TOK_IDENTIFIER, v, l);
        -: 1380:      }
        -: 1381:#endif
        -: 1382:#if 201103L <= YY_CPLUSPLUS
        -: 1383:      static
        -: 1384:      symbol_type
        -: 1385:      make_INT (int v, location_type l)
        -: 1386:      {
        -: 1387:        return symbol_type (token::TOK_INT, std::move (v), std::move (l));
        -: 1388:      }
        -: 1389:#else
        -: 1390:      static
        -: 1391:      symbol_type
        -: 1392:      make_INT (const int& v, const location_type& l)
        -: 1393:      {
        -: 1394:        return symbol_type (token::TOK_INT, v, l);
        -: 1395:      }
        -: 1396:#endif
        -: 1397:#if 201103L <= YY_CPLUSPLUS
        -: 1398:      static
        -: 1399:      symbol_type
        -: 1400:      make_FLOAT (double v, location_type l)
        -: 1401:      {
        -: 1402:        return symbol_type (token::TOK_FLOAT, std::move (v), std::move (l));
        -: 1403:      }
        -: 1404:#else
        -: 1405:      static
        -: 1406:      symbol_type
        -: 1407:      make_FLOAT (const double& v, const location_type& l)
        -: 1408:      {
        -: 1409:        return symbol_type (token::TOK_FLOAT, v, l);
        -: 1410:      }
        -: 1411:#endif
        -: 1412:
        -: 1413:
        -: 1414:    class context
        -: 1415:    {
        -: 1416:    public:
        -: 1417:      context (const parser& yyparser, const symbol_type& yyla);
    #####: 1418:      const symbol_type& lookahead () const { return yyla_; }
    %%%%%: 1418-block  0
    #####: 1419:      symbol_kind_type token () const { return yyla_.kind (); }
    %%%%%: 1419-block  0
        -: 1420:      const location_type& location () const { return yyla_.location; }
        -: 1421:
        -: 1422:      /// Put in YYARG at most YYARGN of the expected tokens, and return the
        -: 1423:      /// number of tokens stored in YYARG.  If YYARG is null, return the
        -: 1424:      /// number of expected tokens (guaranteed to be less than YYNTOKENS).
        -: 1425:      int expected_tokens (symbol_kind_type yyarg[], int yyargn) const;
        -: 1426:
        -: 1427:    private:
        -: 1428:      const parser& yyparser_;
        -: 1429:      const symbol_type& yyla_;
        -: 1430:    };
        -: 1431:
        -: 1432:  private:
        -: 1433:#if YY_CPLUSPLUS < 201103L
        -: 1434:    /// Non copyable.
        -: 1435:    parser (const parser&);
        -: 1436:    /// Non copyable.
        -: 1437:    parser& operator= (const parser&);
        -: 1438:#endif
        -: 1439:
        -: 1440:    /// Check the lookahead yytoken.
        -: 1441:    /// \returns  true iff the token will be eventually shifted.
        -: 1442:    bool yy_lac_check_ (symbol_kind_type yytoken) const;
        -: 1443:    /// Establish the initial context if no initial context currently exists.
        -: 1444:    /// \returns  true iff the token will be eventually shifted.
        -: 1445:    bool yy_lac_establish_ (symbol_kind_type yytoken);
        -: 1446:    /// Discard any previous initial lookahead context because of event.
        -: 1447:    /// \param event  the event which caused the lookahead to be discarded.
        -: 1448:    ///               Only used for debbuging output.
        -: 1449:    void yy_lac_discard_ (const char* event);
        -: 1450:
        -: 1451:    /// Stored state numbers (used for stacks).
        -: 1452:    typedef signed char state_type;
        -: 1453:
        -: 1454:    /// The arguments of the error message.
        -: 1455:    int yy_syntax_error_arguments_ (const context& yyctx,
        -: 1456:                                    symbol_kind_type yyarg[], int yyargn) const;
        -: 1457:
        -: 1458:    /// Generate an error message.
        -: 1459:    /// \param yyctx     the context in which the error occurred.
        -: 1460:    virtual std::string yysyntax_error_ (const context& yyctx) const;
        -: 1461:    /// Compute post-reduction state.
        -: 1462:    /// \param yystate   the current state
        -: 1463:    /// \param yysym     the nonterminal to push on the stack
        -: 1464:    static state_type yy_lr_goto_state_ (state_type yystate, int yysym);
        -: 1465:
        -: 1466:    /// Whether the given \c yypact_ value indicates a defaulted state.
        -: 1467:    /// \param yyvalue   the value to check
        -: 1468:    static bool yy_pact_value_is_default_ (int yyvalue);
        -: 1469:
        -: 1470:    /// Whether the given \c yytable_ value indicates a syntax error.
        -: 1471:    /// \param yyvalue   the value to check
        -: 1472:    static bool yy_table_value_is_error_ (int yyvalue);
        -: 1473:
        -: 1474:    static const signed char yypact_ninf_;
        -: 1475:    static const signed char yytable_ninf_;
        -: 1476:
        -: 1477:    /// Convert a scanner token kind \a t to a symbol kind.
        -: 1478:    /// In theory \a t should be a token_kind_type, but character literals
        -: 1479:    /// are valid, yet not members of the token_type enum.
        -: 1480:    static symbol_kind_type yytranslate_ (int t);
        -: 1481:
        -: 1482:
        -: 1483:
        -: 1484:    // Tables.
        -: 1485:    // YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
        -: 1486:    // STATE-NUM.
        -: 1487:    static const signed char yypact_[];
        -: 1488:
        -: 1489:    // YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
        -: 1490:    // Performed when YYTABLE does not specify something else to do.  Zero
        -: 1491:    // means the default is an error.
        -: 1492:    static const signed char yydefact_[];
        -: 1493:
        -: 1494:    // YYPGOTO[NTERM-NUM].
        -: 1495:    static const signed char yypgoto_[];
        -: 1496:
        -: 1497:    // YYDEFGOTO[NTERM-NUM].
        -: 1498:    static const signed char yydefgoto_[];
        -: 1499:
        -: 1500:    // YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
        -: 1501:    // positive, shift that token.  If negative, reduce the rule whose
        -: 1502:    // number is the opposite.  If YYTABLE_NINF, syntax error.
        -: 1503:    static const signed char yytable_[];
        -: 1504:
        -: 1505:    static const signed char yycheck_[];
        -: 1506:
        -: 1507:    // YYSTOS[STATE-NUM] -- The (internal number of the) accessing
        -: 1508:    // symbol of state STATE-NUM.
        -: 1509:    static const signed char yystos_[];
        -: 1510:
        -: 1511:    // YYR1[YYN] -- Symbol number of symbol that rule YYN derives.
        -: 1512:    static const signed char yyr1_[];
        -: 1513:
        -: 1514:    // YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.
        -: 1515:    static const signed char yyr2_[];
        -: 1516:
        -: 1517:
        -: 1518:#if YYDEBUG
        -: 1519:    // YYRLINE[YYN] -- Source line where rule number YYN was defined.
        -: 1520:    static const unsigned char yyrline_[];
        -: 1521:    /// Report on the debug stream that the rule \a r is going to be reduced.
        -: 1522:    virtual void yy_reduce_print_ (int r) const;
        -: 1523:    /// Print the state stack on the debug stream.
        -: 1524:    virtual void yy_stack_print_ () const;
        -: 1525:
        -: 1526:    /// Debugging level.
        -: 1527:    int yydebug_;
        -: 1528:    /// Debug stream.
        -: 1529:    std::ostream* yycdebug_;
        -: 1530:
        -: 1531:    /// \brief Display a symbol kind, value and location.
        -: 1532:    /// \param yyo    The output stream.
        -: 1533:    /// \param yysym  The symbol.
        -: 1534:    template <typename Base>
        -: 1535:    void yy_print_ (std::ostream& yyo, const basic_symbol<Base>& yysym) const;
        -: 1536:#endif
        -: 1537:
        -: 1538:    /// \brief Reclaim the memory associated to a symbol.
        -: 1539:    /// \param yymsg     Why this token is reclaimed.
        -: 1540:    ///                  If null, print nothing.
        -: 1541:    /// \param yysym     The symbol.
        -: 1542:    template <typename Base>
        -: 1543:    void yy_destroy_ (const char* yymsg, basic_symbol<Base>& yysym) const;
        -: 1544:
        -: 1545:  private:
        -: 1546:    /// Type access provider for state based symbols.
        -: 1547:    struct by_state
        -: 1548:    {
        -: 1549:      /// Default constructor.
        -: 1550:      by_state () YY_NOEXCEPT;
        -: 1551:
        -: 1552:      /// The symbol kind as needed by the constructor.
        -: 1553:      typedef state_type kind_type;
        -: 1554:
        -: 1555:      /// Constructor.
        -: 1556:      by_state (kind_type s) YY_NOEXCEPT;
        -: 1557:
        -: 1558:      /// Copy constructor.
        -: 1559:      by_state (const by_state& that) YY_NOEXCEPT;
        -: 1560:
        -: 1561:      /// Record that this symbol is empty.
        -: 1562:      void clear () YY_NOEXCEPT;
        -: 1563:
        -: 1564:      /// Steal the symbol kind from \a that.
        -: 1565:      void move (by_state& that);
        -: 1566:
        -: 1567:      /// The symbol kind (corresponding to \a state).
        -: 1568:      /// \a symbol_kind::S_YYEMPTY when empty.
        -: 1569:      symbol_kind_type kind () const YY_NOEXCEPT;
        -: 1570:
        -: 1571:      /// The state number used to denote an empty symbol.
        -: 1572:      /// We use the initial state, as it does not have a value.
        -: 1573:      enum { empty_state = 0 };
        -: 1574:
        -: 1575:      /// The state.
        -: 1576:      /// \a empty when empty.
        -: 1577:      state_type state;
        -: 1578:    };
        -: 1579:
        -: 1580:    /// "Internal" symbol: element of the stack.
        -: 1581:    struct stack_symbol_type : basic_symbol<by_state>
        -: 1582:    {
        -: 1583:      /// Superclass.
        -: 1584:      typedef basic_symbol<by_state> super_type;
        -: 1585:      /// Construct an empty symbol.
        -: 1586:      stack_symbol_type ();
        -: 1587:      /// Move or copy construction.
        -: 1588:      stack_symbol_type (YY_RVREF (stack_symbol_type) that);
        -: 1589:      /// Steal the contents from \a sym to build this.
        -: 1590:      stack_symbol_type (state_type s, YY_MOVE_REF (symbol_type) sym);
        -: 1591:#if YY_CPLUSPLUS < 201103L
        -: 1592:      /// Assignment, needed by push_back by some old implementations.
        -: 1593:      /// Moves the contents of that.
        -: 1594:      stack_symbol_type& operator= (stack_symbol_type& that);
        -: 1595:
        -: 1596:      /// Assignment, needed by push_back by other implementations.
        -: 1597:      /// Needed by some other old implementations.
        -: 1598:      stack_symbol_type& operator= (const stack_symbol_type& that);
        -: 1599:#endif
        -: 1600:    };
        -: 1601:
        -: 1602:    /// A stack with random access from its top.
        -: 1603:    template <typename T, typename S = std::vector<T> >
        -: 1604:    class stack
        -: 1605:    {
        -: 1606:    public:
        -: 1607:      // Hide our reversed order.
        -: 1608:      typedef typename S::iterator iterator;
        -: 1609:      typedef typename S::const_iterator const_iterator;
        -: 1610:      typedef typename S::size_type size_type;
        -: 1611:      typedef typename std::ptrdiff_t index_type;
        -: 1612:
        1: 1613:      stack (size_type n = 200)
        1: 1614:        : seq_ (n)
        1: 1614-block  0
        1: 1614-block  1
    $$$$$: 1614-block  2
        1: 1615:      {}
        -: 1616:
        -: 1617:#if 201103L <= YY_CPLUSPLUS
        -: 1618:      /// Non copyable.
        -: 1619:      stack (const stack&) = delete;
        -: 1620:      /// Non copyable.
        -: 1621:      stack& operator= (const stack&) = delete;
        -: 1622:#endif
        -: 1623:
        -: 1624:      /// Random access.
        -: 1625:      ///
        -: 1626:      /// Index 0 returns the topmost element.
        -: 1627:      const T&
      668: 1628:      operator[] (index_type i) const
        -: 1629:      {
      668: 1630:        return seq_[size_type (size () - 1 - i)];
      668: 1630-block  0
        -: 1631:      }
        -: 1632:
        -: 1633:      /// Random access.
        -: 1634:      ///
        -: 1635:      /// Index 0 returns the topmost element.
        -: 1636:      T&
     1880: 1637:      operator[] (index_type i)
        -: 1638:      {
     1880: 1639:        return seq_[size_type (size () - 1 - i)];
     1880: 1639-block  0
        -: 1640:      }
        -: 1641:
        -: 1642:      /// Steal the contents of \a t.
        -: 1643:      ///
        -: 1644:      /// Close to move-semantics.
        -: 1645:      void
      391: 1646:      push (YY_MOVE_REF (T) t)
        -: 1647:      {
      391: 1648:        seq_.push_back (T ());
      391: 1648-block  0
      391: 1648-block  1
    $$$$$: 1648-block  2
      391: 1649:        operator[] (0).move (t);
      391: 1650:      }
        -: 1651:
        -: 1652:      /// Pop elements from the stack.
        -: 1653:      void
      636: 1654:      pop (std::ptrdiff_t n = 1) YY_NOEXCEPT
        -: 1655:      {
      636: 1656:        for (; 0 < n; --n)
      636: 1656-block  0
      390: 1657:          seq_.pop_back ();
      390: 1657-block  0
      246: 1658:      }
        -: 1659:
        -: 1660:      /// Pop all elements from the stack.
        -: 1661:      void
        1: 1662:      clear () YY_NOEXCEPT
        -: 1663:      {
        1: 1664:        seq_.clear ();
        1: 1664-block  0
        1: 1665:      }
        -: 1666:
        -: 1667:      /// Number of elements on the stack.
        -: 1668:      index_type
     2551: 1669:      size () const YY_NOEXCEPT
        -: 1670:      {
     2551: 1671:        return index_type (seq_.size ());
     2551: 1671-block  0
        -: 1672:      }
        -: 1673:
        -: 1674:      /// Iterator on top of the stack (going downwards).
        -: 1675:      const_iterator
    #####: 1676:      begin () const YY_NOEXCEPT
        -: 1677:      {
    #####: 1678:        return seq_.begin ();
    %%%%%: 1678-block  0
        -: 1679:      }
        -: 1680:
        -: 1681:      /// Bottom of the stack.
        -: 1682:      const_iterator
    #####: 1683:      end () const YY_NOEXCEPT
        -: 1684:      {
    #####: 1685:        return seq_.end ();
    %%%%%: 1685-block  0
        -: 1686:      }
        -: 1687:
        -: 1688:      /// Present a slice of the top of a stack.
        -: 1689:      class slice
        -: 1690:      {
        -: 1691:      public:
      243: 1692:        slice (const stack& stack, index_type range)
        -: 1693:          : stack_ (stack)
      243: 1694:          , range_ (range)
      243: 1695:        {}
        -: 1696:
        -: 1697:        const T&
      485: 1698:        operator[] (index_type i) const
        -: 1699:        {
      485: 1700:          return stack_[range_ - i];
      485: 1700-block  0
        -: 1701:        }
        -: 1702:
        -: 1703:      private:
        -: 1704:        const stack& stack_;
        -: 1705:        index_type range_;
        -: 1706:      };
        -: 1707:
        -: 1708:    private:
        -: 1709:#if YY_CPLUSPLUS < 201103L
        -: 1710:      /// Non copyable.
        -: 1711:      stack (const stack&);
        -: 1712:      /// Non copyable.
        -: 1713:      stack& operator= (const stack&);
        -: 1714:#endif
        -: 1715:      /// The wrapped container.
        -: 1716:      S seq_;
        -: 1717:    };
        -: 1718:
        -: 1719:
        -: 1720:    /// Stack type.
        -: 1721:    typedef stack<stack_symbol_type> stack_type;
        -: 1722:
        -: 1723:    /// The stack.
        -: 1724:    stack_type yystack_;
        -: 1725:    /// The stack for LAC.
        -: 1726:    /// Logically, the yy_lac_stack's lifetime is confined to the function
        -: 1727:    /// yy_lac_check_. We just store it as a member of this class to hold
        -: 1728:    /// on to the memory and to avoid frequent reallocations.
        -: 1729:    /// Since yy_lac_check_ is const, this member must be mutable.
        -: 1730:    mutable std::vector<state_type> yylac_stack_;
        -: 1731:    /// Whether an initial LAC context was established.
        -: 1732:    bool yy_lac_established_;
        -: 1733:
        -: 1734:
        -: 1735:    /// Push a new state on the stack.
        -: 1736:    /// \param m    a debug message to display
        -: 1737:    ///             if null, no trace is output.
        -: 1738:    /// \param sym  the symbol
        -: 1739:    /// \warning the contents of \a s.value is stolen.
        -: 1740:    void yypush_ (const char* m, YY_MOVE_REF (stack_symbol_type) sym);
        -: 1741:
        -: 1742:    /// Push a new look ahead token on the state on the stack.
        -: 1743:    /// \param m    a debug message to display
        -: 1744:    ///             if null, no trace is output.
        -: 1745:    /// \param s    the state
        -: 1746:    /// \param sym  the symbol (for its value and location).
        -: 1747:    /// \warning the contents of \a sym.value is stolen.
        -: 1748:    void yypush_ (const char* m, state_type s, YY_MOVE_REF (symbol_type) sym);
        -: 1749:
        -: 1750:    /// Pop \a n symbols from the stack.
        -: 1751:    void yypop_ (int n = 1);
        -: 1752:
        -: 1753:    /// Constants.
        -: 1754:    enum
        -: 1755:    {
        -: 1756:      yylast_ = 69,     ///< Last index in yytable_.
        -: 1757:      yynnts_ = 13,  ///< Number of nonterminal symbols.
        -: 1758:      yyfinal_ = 2 ///< Termination state number.
        -: 1759:    };
        -: 1760:
        -: 1761:
        -: 1762:    // User arguments.
        -: 1763:    driver& drv;
        -: 1764:
        -: 1765:  };
        -: 1766:
        -: 1767:  inline
        -: 1768:  parser::symbol_kind_type
        -: 1769:  parser::yytranslate_ (int t)
        -: 1770:  {
        -: 1771:    return static_cast<symbol_kind_type> (t);
        -: 1772:  }
        -: 1773:
        -: 1774:  // basic_symbol.
        -: 1775:  template <typename Base>
        -: 1776:  parser::basic_symbol<Base>::basic_symbol (const basic_symbol& that)
        -: 1777:    : Base (that)
        -: 1778:    , value ()
        -: 1779:    , location (that.location)
        -: 1780:  {
        -: 1781:    switch (this->kind ())
        -: 1782:    {
        -: 1783:      case symbol_kind::S_dest: // dest
        -: 1784:        value.copy< Dest > (YY_MOVE (that.value));
        -: 1785:        break;
        -: 1786:
        -: 1787:      case symbol_kind::S_value: // value
        -: 1788:      case symbol_kind::S_quadruple: // quadruple
        -: 1789:      case symbol_kind::S_if_statement: // if_statement
        -: 1790:      case symbol_kind::S_goto: // goto
        -: 1791:      case symbol_kind::S_assignment: // assignment
        -: 1792:        value.copy< Quad > (YY_MOVE (that.value));
        -: 1793:        break;
        -: 1794:
        -: 1795:      case symbol_kind::S_FLOAT: // "float"
        -: 1796:        value.copy< double > (YY_MOVE (that.value));
        -: 1797:        break;
        -: 1798:
        -: 1799:      case symbol_kind::S_INT: // "int"
        -: 1800:        value.copy< int > (YY_MOVE (that.value));
        -: 1801:        break;
        -: 1802:
        -: 1803:      case symbol_kind::S_IDENTIFIER: // "identifier"
        -: 1804:      case symbol_kind::S_term: // term
        -: 1805:      case symbol_kind::S_label: // label
        -: 1806:        value.copy< std::string > (YY_MOVE (that.value));
        -: 1807:        break;
        -: 1808:
        -: 1809:      default:
        -: 1810:        break;
        -: 1811:    }
        -: 1812:
        -: 1813:  }
        -: 1814:
        -: 1815:
        -: 1816:
        -: 1817:  template <typename Base>
        -: 1818:  parser::symbol_kind_type
        -: 1819:  parser::basic_symbol<Base>::type_get () const YY_NOEXCEPT
        -: 1820:  {
        -: 1821:    return this->kind ();
        -: 1822:  }
        -: 1823:
        -: 1824:  template <typename Base>
        -: 1825:  bool
     211*: 1826:  parser::basic_symbol<Base>::empty () const YY_NOEXCEPT
        -: 1827:  {
     211*: 1828:    return this->kind () == symbol_kind::S_YYEMPTY;
        -: 1829:  }
------------------
_ZNK2yy6parser12basic_symbolINS0_8by_stateEE5emptyEv:
    #####: 1826:  parser::basic_symbol<Base>::empty () const YY_NOEXCEPT
        -: 1827:  {
    #####: 1828:    return this->kind () == symbol_kind::S_YYEMPTY;
    %%%%%: 1828-block  0
        -: 1829:  }
------------------
_ZNK2yy6parser12basic_symbolINS0_7by_kindEE5emptyEv:
      211: 1826:  parser::basic_symbol<Base>::empty () const YY_NOEXCEPT
        -: 1827:  {
      211: 1828:    return this->kind () == symbol_kind::S_YYEMPTY;
      211: 1828-block  0
        -: 1829:  }
------------------
        -: 1830:
        -: 1831:  template <typename Base>
        -: 1832:  void
      538: 1833:  parser::basic_symbol<Base>::move (basic_symbol& s)
        -: 1834:  {
      538: 1835:    super_type::move (s);
      538: 1836:    switch (this->kind ())
        -: 1837:    {
      21*: 1838:      case symbol_kind::S_dest: // dest
      21*: 1839:        value.move< Dest > (YY_MOVE (s.value));
      21*: 1840:        break;
        -: 1841:
      74*: 1842:      case symbol_kind::S_value: // value
        -: 1843:      case symbol_kind::S_quadruple: // quadruple
        -: 1844:      case symbol_kind::S_if_statement: // if_statement
        -: 1845:      case symbol_kind::S_goto: // goto
        -: 1846:      case symbol_kind::S_assignment: // assignment
      74*: 1847:        value.move< Quad > (YY_MOVE (s.value));
      74*: 1848:        break;
        -: 1849:
    #####: 1850:      case symbol_kind::S_FLOAT: // "float"
    #####: 1851:        value.move< double > (YY_MOVE (s.value));
    #####: 1852:        break;
        -: 1853:
       34: 1854:      case symbol_kind::S_INT: // "int"
       34: 1855:        value.move< int > (YY_MOVE (s.value));
       34: 1856:        break;
        -: 1857:
      135: 1858:      case symbol_kind::S_IDENTIFIER: // "identifier"
        -: 1859:      case symbol_kind::S_term: // term
        -: 1860:      case symbol_kind::S_label: // label
      135: 1861:        value.move< std::string > (YY_MOVE (s.value));
      135: 1862:        break;
        -: 1863:
      274: 1864:      default:
      274: 1865:        break;
        -: 1866:    }
        -: 1867:
      538: 1868:    location = YY_MOVE (s.location);
      538: 1869:  }
------------------
_ZN2yy6parser12basic_symbolINS0_8by_stateEE4moveERS3_:
      391: 1833:  parser::basic_symbol<Base>::move (basic_symbol& s)
        -: 1834:  {
      391: 1835:    super_type::move (s);
      391: 1835-block  0
      391: 1836:    switch (this->kind ())
        -: 1837:    {
       21: 1838:      case symbol_kind::S_dest: // dest
       21: 1839:        value.move< Dest > (YY_MOVE (s.value));
       21: 1839-block  0
       21: 1840:        break;
        -: 1841:
       74: 1842:      case symbol_kind::S_value: // value
        -: 1843:      case symbol_kind::S_quadruple: // quadruple
        -: 1844:      case symbol_kind::S_if_statement: // if_statement
        -: 1845:      case symbol_kind::S_goto: // goto
        -: 1846:      case symbol_kind::S_assignment: // assignment
       74: 1847:        value.move< Quad > (YY_MOVE (s.value));
       74: 1847-block  0
       74: 1848:        break;
        -: 1849:
    #####: 1850:      case symbol_kind::S_FLOAT: // "float"
    #####: 1851:        value.move< double > (YY_MOVE (s.value));
    %%%%%: 1851-block  0
    #####: 1852:        break;
        -: 1853:
       17: 1854:      case symbol_kind::S_INT: // "int"
       17: 1855:        value.move< int > (YY_MOVE (s.value));
       17: 1855-block  0
       17: 1856:        break;
        -: 1857:
       87: 1858:      case symbol_kind::S_IDENTIFIER: // "identifier"
        -: 1859:      case symbol_kind::S_term: // term
        -: 1860:      case symbol_kind::S_label: // label
       87: 1861:        value.move< std::string > (YY_MOVE (s.value));
       87: 1861-block  0
       87: 1862:        break;
        -: 1863:
      192: 1864:      default:
      192: 1865:        break;
      192: 1865-block  0
        -: 1866:    }
        -: 1867:
      391: 1868:    location = YY_MOVE (s.location);
      391: 1868-block  0
      391: 1869:  }
------------------
_ZN2yy6parser12basic_symbolINS0_7by_kindEE4moveERS3_:
      147: 1833:  parser::basic_symbol<Base>::move (basic_symbol& s)
        -: 1834:  {
      147: 1835:    super_type::move (s);
      147: 1835-block  0
      147: 1836:    switch (this->kind ())
        -: 1837:    {
    #####: 1838:      case symbol_kind::S_dest: // dest
    #####: 1839:        value.move< Dest > (YY_MOVE (s.value));
    %%%%%: 1839-block  0
    #####: 1840:        break;
        -: 1841:
    #####: 1842:      case symbol_kind::S_value: // value
        -: 1843:      case symbol_kind::S_quadruple: // quadruple
        -: 1844:      case symbol_kind::S_if_statement: // if_statement
        -: 1845:      case symbol_kind::S_goto: // goto
        -: 1846:      case symbol_kind::S_assignment: // assignment
    #####: 1847:        value.move< Quad > (YY_MOVE (s.value));
    %%%%%: 1847-block  0
    #####: 1848:        break;
        -: 1849:
    #####: 1850:      case symbol_kind::S_FLOAT: // "float"
    #####: 1851:        value.move< double > (YY_MOVE (s.value));
    %%%%%: 1851-block  0
    #####: 1852:        break;
        -: 1853:
       17: 1854:      case symbol_kind::S_INT: // "int"
       17: 1855:        value.move< int > (YY_MOVE (s.value));
       17: 1855-block  0
       17: 1856:        break;
        -: 1857:
       48: 1858:      case symbol_kind::S_IDENTIFIER: // "identifier"
        -: 1859:      case symbol_kind::S_term: // term
        -: 1860:      case symbol_kind::S_label: // label
       48: 1861:        value.move< std::string > (YY_MOVE (s.value));
       48: 1861-block  0
       48: 1862:        break;
        -: 1863:
       82: 1864:      default:
       82: 1865:        break;
       82: 1865-block  0
        -: 1866:    }
        -: 1867:
      147: 1868:    location = YY_MOVE (s.location);
      147: 1868-block  0
      147: 1869:  }
------------------
        -: 1870:
        -: 1871:  // by_kind.
        -: 1872:  inline
        1: 1873:  parser::by_kind::by_kind ()
        1: 1874:    : kind_ (symbol_kind::S_YYEMPTY)
        1: 1875:  {}
        -: 1876:
        -: 1877:#if 201103L <= YY_CPLUSPLUS
        -: 1878:  inline
        -: 1879:  parser::by_kind::by_kind (by_kind&& that)
        -: 1880:    : kind_ (that.kind_)
        -: 1881:  {
        -: 1882:    that.clear ();
        -: 1883:  }
        -: 1884:#endif
        -: 1885:
        -: 1886:  inline
        -: 1887:  parser::by_kind::by_kind (const by_kind& that)
        -: 1888:    : kind_ (that.kind_)
        -: 1889:  {}
        -: 1890:
        -: 1891:  inline
        -: 1892:  parser::by_kind::by_kind (token_kind_type t)
        -: 1893:    : kind_ (yytranslate_ (t))
        -: 1894:  {}
        -: 1895:
        -: 1896:  inline
        -: 1897:  void
      295: 1898:  parser::by_kind::clear ()
        -: 1899:  {
      295: 1900:    kind_ = symbol_kind::S_YYEMPTY;
      295: 1901:  }
        -: 1902:
        -: 1903:  inline
        -: 1904:  void
      147: 1905:  parser::by_kind::move (by_kind& that)
        -: 1906:  {
      147: 1907:    kind_ = that.kind_;
      147: 1908:    that.clear ();
      147: 1908-block  0
      147: 1909:  }
        -: 1910:
        -: 1911:  inline
        -: 1912:  parser::symbol_kind_type
     1347: 1913:  parser::by_kind::kind () const YY_NOEXCEPT
        -: 1914:  {
     1347: 1915:    return kind_;
     1347: 1915-block  0
        -: 1916:  }
        -: 1917:
        -: 1918:  inline
        -: 1919:  parser::symbol_kind_type
        -: 1920:  parser::by_kind::type_get () const YY_NOEXCEPT
        -: 1921:  {
        -: 1922:    return this->kind ();
        -: 1923:  }
        -: 1924:
        -: 1925:} // yy
        -: 1926:#line 1927 "D:/programming/c/tac_parser/cmake-build-debug-coverage/parser.hpp"
        -: 1927:
        -: 1928:
        -: 1929:
        -: 1930:
        -: 1931:#endif // !YY_YY_D_PROGRAMMING_C_TAC_PARSER_CMAKE_BUILD_DEBUG_COVERAGE_PARSER_HPP_INCLUDED
