        -:    0:Source:D:/programming/c/tac_parser/cmake-build-debug-coverage/location.hh
        -:    0:Graph:D:\programming\c\tac_parser\cmake-build-debug-coverage\CMakeFiles\tac_parser.dir\driver\driver.cpp.gcno
        -:    0:Data:D:\programming\c\tac_parser\cmake-build-debug-coverage\CMakeFiles\tac_parser.dir\driver\driver.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// A Bison parser, made by GNU Bison 3.7.1.
        -:    2:
        -:    3:// Locations for Bison parsers in C++
        -:    4:
        -:    5:// Copyright (C) 2002-2015, 2018-2020 Free Software Foundation, Inc.
        -:    6:
        -:    7:// This program is free software: you can redistribute it and/or modify
        -:    8:// it under the terms of the GNU General Public License as published by
        -:    9:// the Free Software Foundation, either version 3 of the License, or
        -:   10:// (at your option) any later version.
        -:   11:
        -:   12:// This program is distributed in the hope that it will be useful,
        -:   13:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   14:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   15:// GNU General Public License for more details.
        -:   16:
        -:   17:// You should have received a copy of the GNU General Public License
        -:   18:// along with this program.  If not, see <http://www.gnu.org/licenses/>.
        -:   19:
        -:   20:// As a special exception, you may create a larger work that contains
        -:   21:// part or all of the Bison parser skeleton and distribute that work
        -:   22:// under terms of your choice, so long as that work isn't itself a
        -:   23:// parser generator using the skeleton or a modified version thereof
        -:   24:// as a parser skeleton.  Alternatively, if you modify or redistribute
        -:   25:// the parser skeleton itself, you may (at your option) remove this
        -:   26:// special exception, which will cause the skeleton and the resulting
        -:   27:// Bison output files to be licensed under the GNU General Public
        -:   28:// License without this special exception.
        -:   29:
        -:   30:// This special exception was added by the Free Software Foundation in
        -:   31:// version 2.2 of Bison.
        -:   32:
        -:   33:/**
        -:   34: ** \file D:/programming/c/tac_parser/cmake-build-debug-coverage/location.hh
        -:   35: ** Define the yy::location class.
        -:   36: */
        -:   37:
        -:   38:#ifndef YY_YY_D_PROGRAMMING_C_TAC_PARSER_CMAKE_BUILD_DEBUG_COVERAGE_LOCATION_HH_INCLUDED
        -:   39:# define YY_YY_D_PROGRAMMING_C_TAC_PARSER_CMAKE_BUILD_DEBUG_COVERAGE_LOCATION_HH_INCLUDED
        -:   40:
        -:   41:# include <iostream>
        -:   42:# include <string>
        -:   43:
        -:   44:# ifndef YY_NULLPTR
        -:   45:#  if defined __cplusplus
        -:   46:#   if 201103L <= __cplusplus
        -:   47:#    define YY_NULLPTR nullptr
        -:   48:#   else
        -:   49:#    define YY_NULLPTR 0
        -:   50:#   endif
        -:   51:#  else
        -:   52:#   define YY_NULLPTR ((void*)0)
        -:   53:#  endif
        -:   54:# endif
        -:   55:
        -:   56:namespace yy {
        -:   57:#line 58 "D:/programming/c/tac_parser/cmake-build-debug-coverage/location.hh"
        -:   58:
        -:   59:  /// A point in a source file.
        -:   60:  class position
        -:   61:  {
        -:   62:  public:
        -:   63:    /// Type for file name.
        -:   64:    typedef const std::string filename_type;
        -:   65:    /// Type for line and column numbers.
        -:   66:    typedef int counter_type;
        -:   67:
        -:   68:    /// Construct a position.
      839:   69:    explicit position (filename_type* f = YY_NULLPTR,
        -:   70:                       counter_type l = 1,
        -:   71:                       counter_type c = 1)
      839:   72:      : filename (f)
        -:   73:      , line (l)
      839:   74:      , column (c)
      839:   75:    {}
        -:   76:
        -:   77:
        -:   78:    /// Initialization.
        1:   79:    void initialize (filename_type* fn = YY_NULLPTR,
        -:   80:                     counter_type l = 1,
        -:   81:                     counter_type c = 1)
        -:   82:    {
        1:   83:      filename = fn;
        1:   84:      line = l;
        1:   85:      column = c;
        1:   86:    }
        -:   87:
        -:   88:    /** \name Line and Column related manipulators
        -:   89:     ** \{ */
        -:   90:    /// (line related) Advance to the COUNT next lines.
        -:   91:    void lines (counter_type count = 1)
        -:   92:    {
        -:   93:      if (count)
        -:   94:        {
        -:   95:          column = 1;
        -:   96:          line = add_ (line, count, 1);
        -:   97:        }
        -:   98:    }
        -:   99:
        -:  100:    /// (column related) Advance to the COUNT next columns.
        -:  101:    void columns (counter_type count = 1)
        -:  102:    {
        -:  103:      column = add_ (column, count, 1);
        -:  104:    }
        -:  105:    /** \} */
        -:  106:
        -:  107:    /// File name to which this position refers.
        -:  108:    filename_type* filename;
        -:  109:    /// Current line number.
        -:  110:    counter_type line;
        -:  111:    /// Current column number.
        -:  112:    counter_type column;
        -:  113:
        -:  114:  private:
        -:  115:    /// Compute max (min, lhs+rhs).
        -:  116:    static counter_type add_ (counter_type lhs, counter_type rhs, counter_type min)
        -:  117:    {
        -:  118:      return lhs + rhs < min ? min : lhs + rhs;
        -:  119:    }
        -:  120:  };
        -:  121:
        -:  122:  /// Add \a width columns, in place.
        -:  123:  inline position&
        -:  124:  operator+= (position& res, position::counter_type width)
        -:  125:  {
        -:  126:    res.columns (width);
        -:  127:    return res;
        -:  128:  }
        -:  129:
        -:  130:  /// Add \a width columns.
        -:  131:  inline position
        -:  132:  operator+ (position res, position::counter_type width)
        -:  133:  {
        -:  134:    return res += width;
        -:  135:  }
        -:  136:
        -:  137:  /// Subtract \a width columns, in place.
        -:  138:  inline position&
        -:  139:  operator-= (position& res, position::counter_type width)
        -:  140:  {
        -:  141:    return res += -width;
        -:  142:  }
        -:  143:
        -:  144:  /// Subtract \a width columns.
        -:  145:  inline position
        -:  146:  operator- (position res, position::counter_type width)
        -:  147:  {
        -:  148:    return res -= width;
        -:  149:  }
        -:  150:
        -:  151:  /** \brief Intercept output stream redirection.
        -:  152:   ** \param ostr the destination output stream
        -:  153:   ** \param pos a reference to the position to redirect
        -:  154:   */
        -:  155:  template <typename YYChar>
        -:  156:  std::basic_ostream<YYChar>&
        -:  157:  operator<< (std::basic_ostream<YYChar>& ostr, const position& pos)
        -:  158:  {
        -:  159:    if (pos.filename)
        -:  160:      ostr << *pos.filename << ':';
        -:  161:    return ostr << pos.line << '.' << pos.column;
        -:  162:  }
        -:  163:
        -:  164:  /// Two points in a source file.
        -:  165:  class location
        -:  166:  {
        -:  167:  public:
        -:  168:    /// Type for file name.
        -:  169:    typedef position::filename_type filename_type;
        -:  170:    /// Type for line and column numbers.
        -:  171:    typedef position::counter_type counter_type;
        -:  172:
        -:  173:    /// Construct a location from \a b to \a e.
        -:  174:    location (const position& b, const position& e)
        -:  175:      : begin (b)
        -:  176:      , end (e)
        -:  177:    {}
        -:  178:
        -:  179:    /// Construct a 0-width location in \a p.
      839:  180:    explicit location (const position& p = position ())
      839:  181:      : begin (p)
      839:  182:      , end (p)
      839:  183:    {}
        -:  184:
        -:  185:    /// Construct a 0-width location in \a f, \a l, \a c.
        -:  186:    explicit location (filename_type* f,
        -:  187:                       counter_type l = 1,
        -:  188:                       counter_type c = 1)
        -:  189:      : begin (f, l, c)
        -:  190:      , end (f, l, c)
        -:  191:    {}
        -:  192:
        -:  193:
        -:  194:    /// Initialization.
        1:  195:    void initialize (filename_type* f = YY_NULLPTR,
        -:  196:                     counter_type l = 1,
        -:  197:                     counter_type c = 1)
        -:  198:    {
        1:  199:      begin.initialize (f, l, c);
        1:  199-block  0
        1:  200:      end = begin;
        1:  201:    }
        -:  202:
        -:  203:    /** \name Line and Column related manipulators
        -:  204:     ** \{ */
        -:  205:  public:
        -:  206:    /// Reset initial location to final location.
        -:  207:    void step ()
        -:  208:    {
        -:  209:      begin = end;
        -:  210:    }
        -:  211:
        -:  212:    /// Extend the current location to the COUNT next columns.
        -:  213:    void columns (counter_type count = 1)
        -:  214:    {
        -:  215:      end += count;
        -:  216:    }
        -:  217:
        -:  218:    /// Extend the current location to the COUNT next lines.
        -:  219:    void lines (counter_type count = 1)
        -:  220:    {
        -:  221:      end.lines (count);
        -:  222:    }
        -:  223:    /** \} */
        -:  224:
        -:  225:
        -:  226:  public:
        -:  227:    /// Beginning of the located region.
        -:  228:    position begin;
        -:  229:    /// End of the located region.
        -:  230:    position end;
        -:  231:  };
        -:  232:
        -:  233:  /// Join two locations, in place.
        -:  234:  inline location&
        -:  235:  operator+= (location& res, const location& end)
        -:  236:  {
        -:  237:    res.end = end.end;
        -:  238:    return res;
        -:  239:  }
        -:  240:
        -:  241:  /// Join two locations.
        -:  242:  inline location
        -:  243:  operator+ (location res, const location& end)
        -:  244:  {
        -:  245:    return res += end;
        -:  246:  }
        -:  247:
        -:  248:  /// Add \a width columns to the end position, in place.
        -:  249:  inline location&
        -:  250:  operator+= (location& res, location::counter_type width)
        -:  251:  {
        -:  252:    res.columns (width);
        -:  253:    return res;
        -:  254:  }
        -:  255:
        -:  256:  /// Add \a width columns to the end position.
        -:  257:  inline location
        -:  258:  operator+ (location res, location::counter_type width)
        -:  259:  {
        -:  260:    return res += width;
        -:  261:  }
        -:  262:
        -:  263:  /// Subtract \a width columns to the end position, in place.
        -:  264:  inline location&
        -:  265:  operator-= (location& res, location::counter_type width)
        -:  266:  {
        -:  267:    return res += -width;
        -:  268:  }
        -:  269:
        -:  270:  /// Subtract \a width columns to the end position.
        -:  271:  inline location
        -:  272:  operator- (location res, location::counter_type width)
        -:  273:  {
        -:  274:    return res -= width;
        -:  275:  }
        -:  276:
        -:  277:  /** \brief Intercept output stream redirection.
        -:  278:   ** \param ostr the destination output stream
        -:  279:   ** \param loc a reference to the location to redirect
        -:  280:   **
        -:  281:   ** Avoid duplicate information.
        -:  282:   */
        -:  283:  template <typename YYChar>
        -:  284:  std::basic_ostream<YYChar>&
        -:  285:  operator<< (std::basic_ostream<YYChar>& ostr, const location& loc)
        -:  286:  {
        -:  287:    location::counter_type end_col
        -:  288:      = 0 < loc.end.column ? loc.end.column - 1 : 0;
        -:  289:    ostr << loc.begin;
        -:  290:    if (loc.end.filename
        -:  291:        && (!loc.begin.filename
        -:  292:            || *loc.begin.filename != *loc.end.filename))
        -:  293:      ostr << '-' << loc.end.filename << ':' << loc.end.line << '.' << end_col;
        -:  294:    else if (loc.begin.line < loc.end.line)
        -:  295:      ostr << '-' << loc.end.line << '.' << end_col;
        -:  296:    else if (loc.begin.column < end_col)
        -:  297:      ostr << '-' << end_col;
        -:  298:    return ostr;
        -:  299:  }
        -:  300:
        -:  301:} // yy
        -:  302:#line 303 "D:/programming/c/tac_parser/cmake-build-debug-coverage/location.hh"
        -:  303:
        -:  304:#endif // !YY_YY_D_PROGRAMMING_C_TAC_PARSER_CMAKE_BUILD_DEBUG_COVERAGE_LOCATION_HH_INCLUDED
