        -:    0:Source:D:/programming/c/tac_parser/cmake-build-debug-coverage/lexer.cpp
        -:    0:Graph:D:\programming\c\tac_parser\cmake-build-debug-coverage\CMakeFiles\tac_parser.dir\lexer.cpp.gcno
        -:    0:Data:D:\programming\c\tac_parser\cmake-build-debug-coverage\CMakeFiles\tac_parser.dir\lexer.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#line 1 "D:/programming/c/tac_parser/cmake-build-debug-coverage/lexer.cpp"
        -:    2:
        -:    3:#line 3 "D:/programming/c/tac_parser/cmake-build-debug-coverage/lexer.cpp"
        -:    4:
        -:    5:#define  YY_INT_ALIGNED short int
        -:    6:
        -:    7:/* A lexical scanner generated by flex */
        -:    8:
        -:    9:/* %not-for-header */
        -:   10:/* %if-c-only */
        -:   11:/* %if-not-reentrant */
        -:   12:
        -:   13:/* %endif */
        -:   14:/* %endif */
        -:   15:/* %ok-for-header */
        -:   16:
        -:   17:#define FLEX_SCANNER
        -:   18:#define YY_FLEX_MAJOR_VERSION 2
        -:   19:#define YY_FLEX_MINOR_VERSION 6
        -:   20:#define YY_FLEX_SUBMINOR_VERSION 4
        -:   21:#if YY_FLEX_SUBMINOR_VERSION > 0
        -:   22:#define FLEX_BETA
        -:   23:#endif
        -:   24:
        -:   25:/* %if-c++-only */
        -:   26:/* %endif */
        -:   27:
        -:   28:/* %if-c-only */
        -:   29:
        -:   30:/* %endif */
        -:   31:
        -:   32:/* %if-c-only */
        -:   33:
        -:   34:/* %endif */
        -:   35:
        -:   36:/* First, we deal with  platform-specific or compiler-specific issues. */
        -:   37:
        -:   38:/* begin standard C headers. */
        -:   39:/* %if-c-only */
        -:   40:#include <stdio.h>
        -:   41:#include <string.h>
        -:   42:#include <errno.h>
        -:   43:#include <stdlib.h>
        -:   44:/* %endif */
        -:   45:
        -:   46:/* %if-tables-serialization */
        -:   47:/* %endif */
        -:   48:/* end standard C headers. */
        -:   49:
        -:   50:/* %if-c-or-c++ */
        -:   51:/* flex integer type definitions */
        -:   52:
        -:   53:#ifndef FLEXINT_H
        -:   54:#define FLEXINT_H
        -:   55:
        -:   56:/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
        -:   57:
        -:   58:#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
        -:   59:
        -:   60:/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
        -:   61: * if you want the limit (max/min) macros for int types. 
        -:   62: */
        -:   63:#ifndef __STDC_LIMIT_MACROS
        -:   64:#define __STDC_LIMIT_MACROS 1
        -:   65:#endif
        -:   66:
        -:   67:#include <inttypes.h>
        -:   68:typedef int8_t flex_int8_t;
        -:   69:typedef uint8_t flex_uint8_t;
        -:   70:typedef int16_t flex_int16_t;
        -:   71:typedef uint16_t flex_uint16_t;
        -:   72:typedef int32_t flex_int32_t;
        -:   73:typedef uint32_t flex_uint32_t;
        -:   74:#else
        -:   75:typedef signed char flex_int8_t;
        -:   76:typedef short int flex_int16_t;
        -:   77:typedef int flex_int32_t;
        -:   78:typedef unsigned char flex_uint8_t; 
        -:   79:typedef unsigned short int flex_uint16_t;
        -:   80:typedef unsigned int flex_uint32_t;
        -:   81:
        -:   82:/* Limits of integral types. */
        -:   83:#ifndef INT8_MIN
        -:   84:#define INT8_MIN               (-128)
        -:   85:#endif
        -:   86:#ifndef INT16_MIN
        -:   87:#define INT16_MIN              (-32767-1)
        -:   88:#endif
        -:   89:#ifndef INT32_MIN
        -:   90:#define INT32_MIN              (-2147483647-1)
        -:   91:#endif
        -:   92:#ifndef INT8_MAX
        -:   93:#define INT8_MAX               (127)
        -:   94:#endif
        -:   95:#ifndef INT16_MAX
        -:   96:#define INT16_MAX              (32767)
        -:   97:#endif
        -:   98:#ifndef INT32_MAX
        -:   99:#define INT32_MAX              (2147483647)
        -:  100:#endif
        -:  101:#ifndef UINT8_MAX
        -:  102:#define UINT8_MAX              (255U)
        -:  103:#endif
        -:  104:#ifndef UINT16_MAX
        -:  105:#define UINT16_MAX             (65535U)
        -:  106:#endif
        -:  107:#ifndef UINT32_MAX
        -:  108:#define UINT32_MAX             (4294967295U)
        -:  109:#endif
        -:  110:
        -:  111:#ifndef SIZE_MAX
        -:  112:#define SIZE_MAX               (~(size_t)0)
        -:  113:#endif
        -:  114:
        -:  115:#endif /* ! C99 */
        -:  116:
        -:  117:#endif /* ! FLEXINT_H */
        -:  118:
        -:  119:/* %endif */
        -:  120:
        -:  121:/* begin standard C++ headers. */
        -:  122:/* %if-c++-only */
        -:  123:/* %endif */
        -:  124:
        -:  125:/* TODO: this is always defined, so inline it */
        -:  126:#define yyconst const
        -:  127:
        -:  128:#if defined(__GNUC__) && __GNUC__ >= 3
        -:  129:#define yynoreturn __attribute__((__noreturn__))
        -:  130:#else
        -:  131:#define yynoreturn
        -:  132:#endif
        -:  133:
        -:  134:/* %not-for-header */
        -:  135:/* Returned upon end-of-file. */
        -:  136:#define YY_NULL 0
        -:  137:/* %ok-for-header */
        -:  138:
        -:  139:/* %not-for-header */
        -:  140:/* Promotes a possibly negative, possibly signed char to an
        -:  141: *   integer in range [0..255] for use as an array index.
        -:  142: */
        -:  143:#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
        -:  144:/* %ok-for-header */
        -:  145:
        -:  146:/* %if-reentrant */
        -:  147:/* %endif */
        -:  148:
        -:  149:/* %if-not-reentrant */
        -:  150:
        -:  151:/* %endif */
        -:  152:
        -:  153:/* Enter a start condition.  This macro really ought to take a parameter,
        -:  154: * but we do it the disgusting crufty way forced on us by the ()-less
        -:  155: * definition of BEGIN.
        -:  156: */
        -:  157:#define BEGIN (yy_start) = 1 + 2 *
        -:  158:/* Translate the current start state into a value that can be later handed
        -:  159: * to BEGIN to return to the state.  The YYSTATE alias is for lex
        -:  160: * compatibility.
        -:  161: */
        -:  162:#define YY_START (((yy_start) - 1) / 2)
        -:  163:#define YYSTATE YY_START
        -:  164:/* Action number for EOF rule of a given start state. */
        -:  165:#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
        -:  166:/* Special action meaning "start processing a new file". */
        -:  167:#define YY_NEW_FILE yyrestart( yyin  )
        -:  168:#define YY_END_OF_BUFFER_CHAR 0
        -:  169:
        -:  170:/* Size of default input buffer. */
        -:  171:#ifndef YY_BUF_SIZE
        -:  172:#ifdef __ia64__
        -:  173:/* On IA-64, the buffer size is 16k, not 8k.
        -:  174: * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
        -:  175: * Ditto for the __ia64__ case accordingly.
        -:  176: */
        -:  177:#define YY_BUF_SIZE 32768
        -:  178:#else
        -:  179:#define YY_BUF_SIZE 16384
        -:  180:#endif /* __ia64__ */
        -:  181:#endif
        -:  182:
        -:  183:/* The state buf must be large enough to hold one state per character in the main buffer.
        -:  184: */
        -:  185:#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
        -:  186:
        -:  187:#ifndef YY_TYPEDEF_YY_BUFFER_STATE
        -:  188:#define YY_TYPEDEF_YY_BUFFER_STATE
        -:  189:typedef struct yy_buffer_state *YY_BUFFER_STATE;
        -:  190:#endif
        -:  191:
        -:  192:#ifndef YY_TYPEDEF_YY_SIZE_T
        -:  193:#define YY_TYPEDEF_YY_SIZE_T
        -:  194:typedef size_t yy_size_t;
        -:  195:#endif
        -:  196:
        -:  197:/* %if-not-reentrant */
        -:  198:extern int yyleng;
        -:  199:/* %endif */
        -:  200:
        -:  201:/* %if-c-only */
        -:  202:/* %if-not-reentrant */
        -:  203:extern FILE *yyin, *yyout;
        -:  204:/* %endif */
        -:  205:/* %endif */
        -:  206:
        -:  207:#define EOB_ACT_CONTINUE_SCAN 0
        -:  208:#define EOB_ACT_END_OF_FILE 1
        -:  209:#define EOB_ACT_LAST_MATCH 2
        -:  210:    
        -:  211:    #define YY_LESS_LINENO(n)
        -:  212:    #define YY_LINENO_REWIND_TO(ptr)
        -:  213:    
        -:  214:/* Return all but the first "n" matched characters back to the input stream. */
        -:  215:#define yyless(n) \
        -:  216:	do \
        -:  217:		{ \
        -:  218:		/* Undo effects of setting up yytext. */ \
        -:  219:        int yyless_macro_arg = (n); \
        -:  220:        YY_LESS_LINENO(yyless_macro_arg);\
        -:  221:		*yy_cp = (yy_hold_char); \
        -:  222:		YY_RESTORE_YY_MORE_OFFSET \
        -:  223:		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
        -:  224:		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        -:  225:		} \
        -:  226:	while ( 0 )
        -:  227:#define unput(c) yyunput( c, (yytext_ptr)  )
        -:  228:
        -:  229:#ifndef YY_STRUCT_YY_BUFFER_STATE
        -:  230:#define YY_STRUCT_YY_BUFFER_STATE
        -:  231:struct yy_buffer_state
        -:  232:	{
        -:  233:/* %if-c-only */
        -:  234:	FILE *yy_input_file;
        -:  235:/* %endif */
        -:  236:
        -:  237:/* %if-c++-only */
        -:  238:/* %endif */
        -:  239:
        -:  240:	char *yy_ch_buf;		/* input buffer */
        -:  241:	char *yy_buf_pos;		/* current position in input buffer */
        -:  242:
        -:  243:	/* Size of input buffer in bytes, not including room for EOB
        -:  244:	 * characters.
        -:  245:	 */
        -:  246:	int yy_buf_size;
        -:  247:
        -:  248:	/* Number of characters read into yy_ch_buf, not including EOB
        -:  249:	 * characters.
        -:  250:	 */
        -:  251:	int yy_n_chars;
        -:  252:
        -:  253:	/* Whether we "own" the buffer - i.e., we know we created it,
        -:  254:	 * and can realloc() it to grow it, and should free() it to
        -:  255:	 * delete it.
        -:  256:	 */
        -:  257:	int yy_is_our_buffer;
        -:  258:
        -:  259:	/* Whether this is an "interactive" input source; if so, and
        -:  260:	 * if we're using stdio for input, then we want to use getc()
        -:  261:	 * instead of fread(), to make sure we stop fetching input after
        -:  262:	 * each newline.
        -:  263:	 */
        -:  264:	int yy_is_interactive;
        -:  265:
        -:  266:	/* Whether we're considered to be at the beginning of a line.
        -:  267:	 * If so, '^' rules will be active on the next match, otherwise
        -:  268:	 * not.
        -:  269:	 */
        -:  270:	int yy_at_bol;
        -:  271:
        -:  272:    int yy_bs_lineno; /**< The line count. */
        -:  273:    int yy_bs_column; /**< The column count. */
        -:  274:
        -:  275:	/* Whether to try to fill the input buffer when we reach the
        -:  276:	 * end of it.
        -:  277:	 */
        -:  278:	int yy_fill_buffer;
        -:  279:
        -:  280:	int yy_buffer_status;
        -:  281:
        -:  282:#define YY_BUFFER_NEW 0
        -:  283:#define YY_BUFFER_NORMAL 1
        -:  284:	/* When an EOF's been seen but there's still some text to process
        -:  285:	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
        -:  286:	 * shouldn't try reading from the input source any more.  We might
        -:  287:	 * still have a bunch of tokens to match, though, because of
        -:  288:	 * possible backing-up.
        -:  289:	 *
        -:  290:	 * When we actually see the EOF, we change the status to "new"
        -:  291:	 * (via yyrestart()), so that the user can continue scanning by
        -:  292:	 * just pointing yyin at a new input file.
        -:  293:	 */
        -:  294:#define YY_BUFFER_EOF_PENDING 2
        -:  295:
        -:  296:	};
        -:  297:#endif /* !YY_STRUCT_YY_BUFFER_STATE */
        -:  298:
        -:  299:/* %if-c-only Standard (non-C++) definition */
        -:  300:/* %not-for-header */
        -:  301:/* %if-not-reentrant */
        -:  302:
        -:  303:/* Stack of input buffers. */
        -:  304:static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
        -:  305:static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
        -:  306:static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
        -:  307:/* %endif */
        -:  308:/* %ok-for-header */
        -:  309:
        -:  310:/* %endif */
        -:  311:
        -:  312:/* We provide macros for accessing buffer states in case in the
        -:  313: * future we want to put the buffer states in a more general
        -:  314: * "scanner state".
        -:  315: *
        -:  316: * Returns the top of the stack, or NULL.
        -:  317: */
        -:  318:#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
        -:  319:                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
        -:  320:                          : NULL)
        -:  321:/* Same as previous macro, but useful when we know that the buffer stack is not
        -:  322: * NULL or when we need an lvalue. For internal use only.
        -:  323: */
        -:  324:#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
        -:  325:
        -:  326:/* %if-c-only Standard (non-C++) definition */
        -:  327:
        -:  328:/* %if-not-reentrant */
        -:  329:/* %not-for-header */
        -:  330:/* yy_hold_char holds the character lost when yytext is formed. */
        -:  331:static char yy_hold_char;
        -:  332:static int yy_n_chars;		/* number of characters read into yy_ch_buf */
        -:  333:int yyleng;
        -:  334:
        -:  335:/* Points to current character in buffer. */
        -:  336:static char *yy_c_buf_p = NULL;
        -:  337:static int yy_init = 0;		/* whether we need to initialize */
        -:  338:static int yy_start = 0;	/* start state number */
        -:  339:
        -:  340:/* Flag which is used to allow yywrap()'s to do buffer switches
        -:  341: * instead of setting up a fresh yyin.  A bit of a hack ...
        -:  342: */
        -:  343:static int yy_did_buffer_switch_on_eof;
        -:  344:/* %ok-for-header */
        -:  345:
        -:  346:/* %endif */
        -:  347:
        -:  348:void yyrestart ( FILE *input_file  );
        -:  349:void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
        -:  350:YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
        -:  351:void yy_delete_buffer ( YY_BUFFER_STATE b  );
        -:  352:void yy_flush_buffer ( YY_BUFFER_STATE b  );
        -:  353:void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
        -:  354:void yypop_buffer_state ( void );
        -:  355:
        -:  356:static void yyensure_buffer_stack ( void );
        -:  357:static void yy_load_buffer_state ( void );
        -:  358:static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
        -:  359:#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
        -:  360:
        -:  361:YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
        -:  362:YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
        -:  363:YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
        -:  364:
        -:  365:/* %endif */
        -:  366:
        -:  367:void *yyalloc ( yy_size_t  );
        -:  368:void *yyrealloc ( void *, yy_size_t  );
        -:  369:void yyfree ( void *  );
        -:  370:
        -:  371:#define yy_new_buffer yy_create_buffer
        -:  372:#define yy_set_interactive(is_interactive) \
        -:  373:	{ \
        -:  374:	if ( ! YY_CURRENT_BUFFER ){ \
        -:  375:        yyensure_buffer_stack (); \
        -:  376:		YY_CURRENT_BUFFER_LVALUE =    \
        -:  377:            yy_create_buffer( yyin, YY_BUF_SIZE ); \
        -:  378:	} \
        -:  379:	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
        -:  380:	}
        -:  381:#define yy_set_bol(at_bol) \
        -:  382:	{ \
        -:  383:	if ( ! YY_CURRENT_BUFFER ){\
        -:  384:        yyensure_buffer_stack (); \
        -:  385:		YY_CURRENT_BUFFER_LVALUE =    \
        -:  386:            yy_create_buffer( yyin, YY_BUF_SIZE ); \
        -:  387:	} \
        -:  388:	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
        -:  389:	}
        -:  390:#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
        -:  391:
        -:  392:/* %% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here */
        -:  393:/* Begin user sect3 */
        -:  394:
        -:  395:#define yywrap() (/*CONSTCOND*/1)
        -:  396:#define YY_SKIP_YYWRAP
        -:  397:
        -:  398:#define FLEX_DEBUG
        -:  399:typedef flex_uint8_t YY_CHAR;
        -:  400:
        -:  401:FILE *yyin = NULL, *yyout = NULL;
        -:  402:
        -:  403:typedef int yy_state_type;
        -:  404:
        -:  405:extern int yylineno;
        -:  406:int yylineno = 1;
        -:  407:
        -:  408:extern char *yytext;
        -:  409:#ifdef yytext_ptr
        -:  410:#undef yytext_ptr
        -:  411:#endif
        -:  412:#define yytext_ptr yytext
        -:  413:
        -:  414:/* %% [1.5] DFA */
        -:  415:
        -:  416:/* %if-c-only Standard (non-C++) definition */
        -:  417:
        -:  418:static yy_state_type yy_get_previous_state ( void );
        -:  419:static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
        -:  420:static int yy_get_next_buffer ( void );
        -:  421:static void yynoreturn yy_fatal_error ( const char* msg  );
        -:  422:
        -:  423:/* %endif */
        -:  424:
        -:  425:/* Done after the current pattern has been matched and before the
        -:  426: * corresponding action - sets up yytext.
        -:  427: */
        -:  428:#define YY_DO_BEFORE_ACTION \
        -:  429:	(yytext_ptr) = yy_bp; \
        -:  430:/* %% [2.0] code to fiddle yytext and yyleng for yymore() goes here \ */\
        -:  431:	yyleng = (int) (yy_cp - yy_bp); \
        -:  432:	(yy_hold_char) = *yy_cp; \
        -:  433:	*yy_cp = '\0'; \
        -:  434:/* %% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \ */\
        -:  435:	(yy_c_buf_p) = yy_cp;
        -:  436:/* %% [4.0] data tables for the DFA and the user's section 1 definitions go here */
        -:  437:#define YY_NUM_RULES 25
        -:  438:#define YY_END_OF_BUFFER 26
        -:  439:/* This struct is not used in this scanner,
        -:  440:   but its presence is necessary. */
        -:  441:struct yy_trans_info
        -:  442:	{
        -:  443:	flex_int32_t yy_verify;
        -:  444:	flex_int32_t yy_nxt;
        -:  445:	};
        -:  446:static const flex_int16_t yy_accept[40] =
        -:  447:    {   0,
        -:  448:        0,    0,   26,   24,    3,    2,   24,   23,   10,   17,
        -:  449:       18,    8,    6,    7,    9,   22,   16,   15,   11,    5,
        -:  450:       12,   19,   20,    3,    1,    3,   14,   23,    0,   21,
        -:  451:       22,   13,    3,    1,    1,    0,    4,   21,    0
        -:  452:    } ;
        -:  453:
        -:  454:static const YY_CHAR yy_ec[256] =
        -:  455:    {   0,
        -:  456:        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        -:  457:        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        -:  458:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  459:        1,    2,    4,    1,    1,    5,    1,    6,    1,    7,
        -:  460:        8,    9,   10,    1,   11,   12,   13,   14,   14,   14,
        -:  461:       14,   14,   14,   14,   14,   14,   14,   15,   16,   17,
        -:  462:       18,   19,    1,    1,   20,   20,   20,   20,   20,   20,
        -:  463:       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
        -:  464:       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
        -:  465:       21,    1,   22,    1,   20,    1,   20,   20,   20,   20,
        -:  466:
        -:  467:       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
        -:  468:       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
        -:  469:       20,   20,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  470:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  471:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  472:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  473:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  474:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  475:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  476:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  477:
        -:  478:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  479:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  480:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  481:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  482:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  483:        1,    1,    1,    1,    1
        -:  484:    } ;
        -:  485:
        -:  486:static const YY_CHAR yy_meta[23] =
        -:  487:    {   0,
        -:  488:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  489:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  490:        1,    1
        -:  491:    } ;
        -:  492:
        -:  493:static const flex_int16_t yy_base[41] =
        -:  494:    {   0,
        -:  495:        0,   21,   50,   51,   47,   51,   30,   11,   51,   51,
        -:  496:       51,   51,   51,   51,   34,   14,   51,   51,   51,   28,
        -:  497:       51,   51,   51,   27,   40,   42,   51,   13,   40,   28,
        -:  498:       20,   51,   33,   36,   35,   36,   51,   24,   51,   36
        -:  499:    } ;
        -:  500:
        -:  501:static const flex_int16_t yy_def[41] =
        -:  502:    {   0,
        -:  503:       39,    1,   39,   39,   39,   39,   39,   39,   39,   39,
        -:  504:       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
        -:  505:       39,   39,   39,   39,   39,   39,   39,   39,   40,   39,
        -:  506:       39,   39,   39,   39,   39,   40,   39,   39,    0,   39
        -:  507:    } ;
        -:  508:
        -:  509:static const flex_int16_t yy_nxt[74] =
        -:  510:    {   0,
        -:  511:        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
        -:  512:       14,    4,   15,   16,   17,   18,   19,   20,   21,    8,
        -:  513:       22,   23,   24,   25,   28,   30,   28,   31,   33,   34,
        -:  514:       28,   30,   28,   31,   33,   34,   36,   38,   37,   35,
        -:  515:       35,   38,   37,   26,   35,   32,   29,   27,   26,   39,
        -:  516:        3,   39,   39,   39,   39,   39,   39,   39,   39,   39,
        -:  517:       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
        -:  518:       39,   39,   39
        -:  519:    } ;
        -:  520:
        -:  521:static const flex_int16_t yy_chk[74] =
        -:  522:    {   0,
        -:  523:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  524:        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        -:  525:        1,    1,    2,    2,    8,   16,   28,   16,   24,   24,
        -:  526:        8,   31,   28,   31,   33,   33,   40,   38,   36,   35,
        -:  527:       34,   30,   29,   26,   25,   20,   15,    7,    5,    3,
        -:  528:       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
        -:  529:       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
        -:  530:       39,   39,   39
        -:  531:    } ;
        -:  532:
        -:  533:static yy_state_type yy_last_accepting_state;
        -:  534:static char *yy_last_accepting_cpos;
        -:  535:
        -:  536:extern int yy_flex_debug;
        -:  537:int yy_flex_debug = 1;
        -:  538:
        -:  539:static const flex_int16_t yy_rule_linenum[25] =
        -:  540:    {   0,
        -:  541:       35,   36,   37,   38,   40,   41,   42,   43,   44,   45,
        -:  542:       47,   48,   49,   50,   53,   54,   55,   56,   57,   58,
        -:  543:       60,   61,   62,   64
        -:  544:    } ;
        -:  545:
        -:  546:/* The intent behind this definition is that it'll catch
        -:  547: * any uses of REJECT which flex missed.
        -:  548: */
        -:  549:#define REJECT reject_used_but_not_detected
        -:  550:#define yymore() yymore_used_but_not_detected
        -:  551:#define YY_MORE_ADJ 0
        -:  552:#define YY_RESTORE_YY_MORE_OFFSET
        -:  553:char *yytext;
        -:  554:#line 1 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  555:#line 2 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  556:    //#pragma warning (disable : 4005)
        -:  557:    #include <climits>
        -:  558:    #include <cstring>
        -:  559:    #include <string>
        -:  560:    #include <functional>
        -:  561:    #include <map>
        -:  562:    #include "../driver/driver.hpp"
        -:  563:#line 563 "D:/programming/c/tac_parser/cmake-build-debug-coverage/lexer.cpp"
        -:  564:#define YY_NO_INPUT 1
        -:  565:#line 14 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  566:    yy::parser::symbol_type make_NUMBER(const std::string& s, const yy::parser::location_type& loc, bool);
        -:  567:    yy::parser::symbol_type make_IDENTIFIER(const std::string& s, const yy::parser::location_type& loc);
        -:  568:    #define YY_USER_ACTION loc.columns(yyleng);
        -:  569:#line 569 "D:/programming/c/tac_parser/cmake-build-debug-coverage/lexer.cpp"
        -:  570:#line 570 "D:/programming/c/tac_parser/cmake-build-debug-coverage/lexer.cpp"
        -:  571:
        -:  572:#define INITIAL 0
        -:  573:
        -:  574:/*windows compatibility case*/
        -:  575:#include <io.h>
        -:  576:#define isatty _isatty
        -:  577:#define fileno _fileno
        -:  578:    
        -:  579:#ifndef YY_EXTRA_TYPE
        -:  580:#define YY_EXTRA_TYPE void *
        -:  581:#endif
        -:  582:
        -:  583:/* %if-c-only Reentrant structure and macros (non-C++). */
        -:  584:/* %if-reentrant */
        -:  585:/* %if-c-only */
        -:  586:
        -:  587:static int yy_init_globals ( void );
        -:  588:
        -:  589:/* %endif */
        -:  590:/* %if-reentrant */
        -:  591:/* %endif */
        -:  592:/* %endif End reentrant structures and macros. */
        -:  593:
        -:  594:/* Accessor methods to globals.
        -:  595:   These are made visible to non-reentrant scanners for convenience. */
        -:  596:
        -:  597:int yylex_destroy ( void );
        -:  598:
        -:  599:int yyget_debug ( void );
        -:  600:
        -:  601:void yyset_debug ( int debug_flag  );
        -:  602:
        -:  603:YY_EXTRA_TYPE yyget_extra ( void );
        -:  604:
        -:  605:void yyset_extra ( YY_EXTRA_TYPE user_defined  );
        -:  606:
        -:  607:FILE *yyget_in ( void );
        -:  608:
        -:  609:void yyset_in  ( FILE * _in_str  );
        -:  610:
        -:  611:FILE *yyget_out ( void );
        -:  612:
        -:  613:void yyset_out  ( FILE * _out_str  );
        -:  614:
        -:  615:			int yyget_leng ( void );
        -:  616:
        -:  617:char *yyget_text ( void );
        -:  618:
        -:  619:int yyget_lineno ( void );
        -:  620:
        -:  621:void yyset_lineno ( int _line_number  );
        -:  622:
        -:  623:/* %if-bison-bridge */
        -:  624:/* %endif */
        -:  625:
        -:  626:/* Macros after this point can all be overridden by user definitions in
        -:  627: * section 1.
        -:  628: */
        -:  629:
        -:  630:#ifndef YY_SKIP_YYWRAP
        -:  631:#ifdef __cplusplus
        -:  632:extern "C" int yywrap ( void );
        -:  633:#else
        -:  634:extern int yywrap ( void );
        -:  635:#endif
        -:  636:#endif
        -:  637:
        -:  638:/* %not-for-header */
        -:  639:#ifndef YY_NO_UNPUT
        -:  640:    
        -:  641:#endif
        -:  642:/* %ok-for-header */
        -:  643:
        -:  644:/* %endif */
        -:  645:
        -:  646:#ifndef yytext_ptr
        -:  647:static void yy_flex_strncpy ( char *, const char *, int );
        -:  648:#endif
        -:  649:
        -:  650:#ifdef YY_NEED_STRLEN
        -:  651:static int yy_flex_strlen ( const char * );
        -:  652:#endif
        -:  653:
        -:  654:#ifndef YY_NO_INPUT
        -:  655:/* %if-c-only Standard (non-C++) definition */
        -:  656:/* %not-for-header */
        -:  657:#ifdef __cplusplus
        -:  658:static int yyinput ( void );
        -:  659:#else
        -:  660:static int input ( void );
        -:  661:#endif
        -:  662:/* %ok-for-header */
        -:  663:
        -:  664:/* %endif */
        -:  665:#endif
        -:  666:
        -:  667:/* %if-c-only */
        -:  668:
        -:  669:/* %endif */
        -:  670:
        -:  671:/* Amount of stuff to slurp up with each read. */
        -:  672:#ifndef YY_READ_BUF_SIZE
        -:  673:#ifdef __ia64__
        -:  674:/* On IA-64, the buffer size is 16k, not 8k */
        -:  675:#define YY_READ_BUF_SIZE 16384
        -:  676:#else
        -:  677:#define YY_READ_BUF_SIZE 8192
        -:  678:#endif /* __ia64__ */
        -:  679:#endif
        -:  680:
        -:  681:/* Copy whatever the last rule matched to the standard output. */
        -:  682:#ifndef ECHO
        -:  683:/* %if-c-only Standard (non-C++) definition */
        -:  684:/* This used to be an fputs(), but since the string might contain NUL's,
        -:  685: * we now use fwrite().
        -:  686: */
        -:  687:#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
        -:  688:/* %endif */
        -:  689:/* %if-c++-only C++ definition */
        -:  690:/* %endif */
        -:  691:#endif
        -:  692:
        -:  693:/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
        -:  694: * is returned in "result".
        -:  695: */
        -:  696:#ifndef YY_INPUT
        -:  697:#define YY_INPUT(buf,result,max_size) \
        -:  698:/* %% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \ */\
        -:  699:	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
        -:  700:		{ \
        -:  701:		int c = '*'; \
        -:  702:		int n; \
        -:  703:		for ( n = 0; n < max_size && \
        -:  704:			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
        -:  705:			buf[n] = (char) c; \
        -:  706:		if ( c == '\n' ) \
        -:  707:			buf[n++] = (char) c; \
        -:  708:		if ( c == EOF && ferror( yyin ) ) \
        -:  709:			YY_FATAL_ERROR( "input in flex scanner failed" ); \
        -:  710:		result = n; \
        -:  711:		} \
        -:  712:	else \
        -:  713:		{ \
        -:  714:		errno=0; \
        -:  715:		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
        -:  716:			{ \
        -:  717:			if( errno != EINTR) \
        -:  718:				{ \
        -:  719:				YY_FATAL_ERROR( "input in flex scanner failed" ); \
        -:  720:				break; \
        -:  721:				} \
        -:  722:			errno=0; \
        -:  723:			clearerr(yyin); \
        -:  724:			} \
        -:  725:		}\
        -:  726:\
        -:  727:/* %if-c++-only C++ definition \ */\
        -:  728:/* %endif */
        -:  729:
        -:  730:#endif
        -:  731:
        -:  732:/* No semi-colon after return; correct usage is to write "yyterminate();" -
        -:  733: * we don't want an extra ';' after the "return" because that will cause
        -:  734: * some compilers to complain about unreachable statements.
        -:  735: */
        -:  736:#ifndef yyterminate
        -:  737:#define yyterminate() return YY_NULL
        -:  738:#endif
        -:  739:
        -:  740:/* Number of entries by which start-condition stack grows. */
        -:  741:#ifndef YY_START_STACK_INCR
        -:  742:#define YY_START_STACK_INCR 25
        -:  743:#endif
        -:  744:
        -:  745:/* Report a fatal error. */
        -:  746:#ifndef YY_FATAL_ERROR
        -:  747:/* %if-c-only */
        -:  748:#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
        -:  749:/* %endif */
        -:  750:/* %if-c++-only */
        -:  751:/* %endif */
        -:  752:#endif
        -:  753:
        -:  754:/* %if-tables-serialization structures and prototypes */
        -:  755:/* %not-for-header */
        -:  756:/* %ok-for-header */
        -:  757:
        -:  758:/* %not-for-header */
        -:  759:/* %tables-yydmap generated elements */
        -:  760:/* %endif */
        -:  761:/* end tables serialization structures and prototypes */
        -:  762:
        -:  763:/* %ok-for-header */
        -:  764:
        -:  765:/* Default declaration of generated scanner - a define so the user can
        -:  766: * easily add parameters.
        -:  767: */
        -:  768:#ifndef YY_DECL
        -:  769:#define YY_DECL_IS_OURS 1
        -:  770:/* %if-c-only Standard (non-C++) definition */
        -:  771:
        -:  772:extern int yylex (void);
        -:  773:
        -:  774:#define YY_DECL int yylex (void)
        -:  775:/* %endif */
        -:  776:/* %if-c++-only C++ definition */
        -:  777:/* %endif */
        -:  778:#endif /* !YY_DECL */
        -:  779:
        -:  780:/* Code executed at the beginning of each rule, after yytext and yyleng
        -:  781: * have been set up.
        -:  782: */
        -:  783:#ifndef YY_USER_ACTION
        -:  784:#define YY_USER_ACTION
        -:  785:#endif
        -:  786:
        -:  787:/* Code executed at the end of each rule. */
        -:  788:#ifndef YY_BREAK
        -:  789:#define YY_BREAK /*LINTED*/break;
        -:  790:#endif
        -:  791:
        -:  792:/* %% [6.0] YY_RULE_SETUP definition goes here */
        -:  793:#define YY_RULE_SETUP \
        -:  794:	if ( yyleng > 0 ) \
        -:  795:		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
        -:  796:				(yytext[yyleng - 1] == '\n'); \
        -:  797:	YY_USER_ACTION
        -:  798:
        -:  799:/* %not-for-header */
        -:  800:/** The main scanner function which does all the work.
      147:  801: */
        -:  802:YY_DECL
        -:  803:{
        -:  804:	yy_state_type yy_current_state;
        -:  805:	char *yy_cp, *yy_bp;
        -:  806:	int yy_act;
      147:  807:    
      147:  807-block  0
        -:  808:	if ( !(yy_init) )
        1:  809:		{
        -:  810:		(yy_init) = 1;
        -:  811:
        -:  812:#ifdef YY_USER_INIT
        -:  813:		YY_USER_INIT;
        -:  814:#endif
        1:  815:
        1:  815-block  0
        1:  816:		if ( ! (yy_start) )
        1:  816-block  0
        -:  817:			(yy_start) = 1;	/* first start state */
        1:  818:
        1:  818-block  0
        -:  819:		if ( ! yyin )
    #####:  820:/* %if-c-only */
    %%%%%:  820-block  0
        -:  821:			yyin = stdin;
        -:  822:/* %endif */
        -:  823:/* %if-c++-only */
        -:  824:/* %endif */
        1:  825:
        1:  825-block  0
        -:  826:		if ( ! yyout )
        1:  827:/* %if-c-only */
        1:  827-block  0
        -:  828:			yyout = stdout;
        -:  829:/* %endif */
        -:  830:/* %if-c++-only */
        -:  831:/* %endif */
       1*:  832:
        1:  832-block  0
    %%%%%:  832-block  1
        1:  833:		if ( ! YY_CURRENT_BUFFER ) {
        1:  833-block  0
        2:  834:			yyensure_buffer_stack ();
        1:  835:			YY_CURRENT_BUFFER_LVALUE =
        -:  836:				yy_create_buffer( yyin, YY_BUF_SIZE );
        -:  837:		}
        1:  838:
        1:  838-block  0
        -:  839:		yy_load_buffer_state(  );
        -:  840:		}
        -:  841:
        -:  842:	{
        -:  843:/* %% [7.0] user's declarations go here */
        -:  844:#line 27 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  845:
        -:  846:
        -:  847:
        -:  848:#line 31 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  849:    yy::location& loc = drv.location;
        -:  850:    loc.step();
        -:  851:
        -:  852:
        -:  853:#line 853 "D:/programming/c/tac_parser/cmake-build-debug-coverage/lexer.cpp"
        -:  854:
        -:  855:	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
        -:  856:		{
      325:  857:/* %% [8.0] yymore()-related code goes here */
        -:  858:		yy_cp = (yy_c_buf_p);
        -:  859:
      325:  860:		/* Support of yytext. */
        -:  861:		*yy_cp = (yy_hold_char);
        -:  862:
        -:  863:		/* yy_bp points to the position in yy_ch_buf of the start of
        -:  864:		 * the current run.
      325:  865:		 */
        -:  866:		yy_bp = yy_cp;
        -:  867:
      325:  868:/* %% [9.0] code to set up and find next match goes here */
      325:  869:		yy_current_state = (yy_start);
      325:  869-block  0
     1863:  870:		yy_current_state += YY_AT_BOL();
     1537:  871:yy_match:
     1537:  871-block  0
        -:  872:		do
     1863:  873:			{
     1863:  874:			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
     1863:  874-block  0
        -:  875:			if ( yy_accept[yy_current_state] )
      539:  876:				{
      539:  877:				(yy_last_accepting_state) = yy_current_state;
      539:  877-block  0
        -:  878:				(yy_last_accepting_cpos) = yy_cp;
     3198:  879:				}
     3198:  879-block  0
     1335:  879-block  1
        -:  880:			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
     1335:  881:				{
     1335:  882:				yy_current_state = (int) yy_def[yy_current_state];
     1335:  882-block  0
      918:  883:				if ( yy_current_state >= 40 )
      918:  883-block  0
        -:  884:					yy_c = yy_meta[yy_c];
     1863:  885:				}
     1863:  886:			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        -:  887:			++yy_cp;
     1863:  888:			}
     1863:  888-block  0
      326:  889:		while ( yy_current_state != 39 );
      326:  890:		yy_cp = (yy_last_accepting_cpos);
      326:  890-block  0
        -:  891:		yy_current_state = (yy_last_accepting_state);
      327:  892:
        -:  893:yy_find_action:
      327:  894:/* %% [10.0] code to find the action number goes here */
        -:  895:		yy_act = yy_accept[yy_current_state];
      327:  896:
      327:  896-block  0
        -:  897:		YY_DO_BEFORE_ACTION;
        -:  898:
        -:  899:/* %% [11.0] code for yylineno update goes here */
      328:  900:
        -:  901:do_action:	/* This label is used only to access EOF actions. */
        -:  902:
      328:  903:/* %% [12.0] debug code goes here */
      328:  903-block  0
        -:  904:		if ( yy_flex_debug )
    #####:  905:			{
    %%%%%:  905-block  0
    #####:  906:			if ( yy_act == 0 )
    %%%%%:  906-block  0
    #####:  907:				fprintf( stderr, "--scanner backing up\n" );
    %%%%%:  907-block  0
    #####:  908:			else if ( yy_act < 25 )
    #####:  909:				fprintf( stderr, "--accepting rule at line %ld (\"%s\")\n",
    %%%%%:  909-block  0
    #####:  910:				         (long)yy_rule_linenum[yy_act], yytext );
    %%%%%:  910-block  0
    #####:  911:			else if ( yy_act == 25 )
    %%%%%:  911-block  0
        -:  912:				fprintf( stderr, "--accepting default rule (\"%s\")\n",
    #####:  913:				         yytext );
    %%%%%:  913-block  0
    #####:  914:			else if ( yy_act == 26 )
    %%%%%:  914-block  0
        -:  915:				fprintf( stderr, "--(end of buffer or a NUL)\n" );
    #####:  916:			else
    %%%%%:  916-block  0
        -:  917:				fprintf( stderr, "--EOF (start condition %d)\n", YY_START );
        -:  918:			}
      328:  919:
      328:  919-block  0
        -:  920:		switch ( yy_act )
        -:  921:	{ /* beginning of action switch */
    #####:  922:/* %% [13.0] actions go here */
        -:  923:			case 0: /* must back up */
    #####:  924:			/* undo the effects of YY_DO_BEFORE_ACTION */
    #####:  925:			*yy_cp = (yy_hold_char);
    #####:  926:			yy_cp = (yy_last_accepting_cpos);
    #####:  927:			yy_current_state = (yy_last_accepting_state);
    %%%%%:  927-block  0
        -:  928:			goto yy_find_action;
        6:  929:
        -:  930:case 1:
        6:  931:/* rule 1 can match eol */
        6:  931-block  0
        6:  931-block  1
        6:  931-block  2
        -:  932:YY_RULE_SETUP
        -:  933:#line 35 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  934:loc.lines(yyleng); loc.step();
        -:  935:	YY_BREAK
        -:  936:case 2:
        -:  937:/* rule 2 can match eol */
        -:  938:YY_RULE_SETUP
        -:  939:#line 36 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  940:loc.lines(yyleng); loc.step(); return yy::parser::make_NEWLINE(loc);
        -:  941:	YY_BREAK
        -:  942:case 3:
        -:  943:YY_RULE_SETUP
        -:  944:#line 37 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  945:loc.step();
        -:  946:	YY_BREAK
        -:  947:case 4:
        -:  948:/* rule 4 can match eol */
        -:  949:YY_RULE_SETUP
        -:  950:#line 38 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  951:loc.step();
        -:  952:	YY_BREAK
        -:  953:case 5:
        -:  954:YY_RULE_SETUP
        -:  955:#line 40 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  956:return yy::parser::make_ASSIGN(loc);
        -:  957:	YY_BREAK
        -:  958:case 6:
        -:  959:YY_RULE_SETUP
        -:  960:#line 41 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  961:return yy::parser::make_PLUS(loc);
        -:  962:	YY_BREAK
        -:  963:case 7:
        -:  964:YY_RULE_SETUP
        -:  965:#line 42 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  966:return yy::parser::make_MINUS(loc);
        -:  967:	YY_BREAK
        -:  968:case 8:
        -:  969:YY_RULE_SETUP
        -:  970:#line 43 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  971:return yy::parser::make_MULT(loc);
        -:  972:	YY_BREAK
        -:  973:case 9:
        -:  974:YY_RULE_SETUP
        -:  975:#line 44 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  976:return yy::parser::make_DIV(loc);
        -:  977:	YY_BREAK
        -:  978:case 10:
        -:  979:YY_RULE_SETUP
        -:  980:#line 45 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  981:return yy::parser::make_REF(loc);
        -:  982:	YY_BREAK
        -:  983:case 11:
        -:  984:YY_RULE_SETUP
        -:  985:#line 47 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  986:return yy::parser::make_CMP_LT(loc);
        -:  987:	YY_BREAK
        -:  988:case 12:
        -:  989:YY_RULE_SETUP
        -:  990:#line 48 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  991:return yy::parser::make_CMP_GT(loc);
        -:  992:	YY_BREAK
        -:  993:case 13:
        -:  994:YY_RULE_SETUP
        -:  995:#line 49 "D:/programming/c/tac_parser/grammar/lexer.l"
        -:  996:return yy::parser::make_CMP_EQ(loc);
        -:  997:	YY_BREAK
        -:  998:case 14:
        -:  999:YY_RULE_SETUP
        -: 1000:#line 50 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1001:return yy::parser::make_CMP_NEQ(loc);
        -: 1002:	YY_BREAK
        -: 1003:case 15:
        -: 1004:YY_RULE_SETUP
        -: 1005:#line 53 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1006:return yy::parser::make_SEMI(loc);
        -: 1007:	YY_BREAK
        -: 1008:case 16:
        -: 1009:YY_RULE_SETUP
        -: 1010:#line 54 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1011:return yy::parser::make_COLON(loc);
        -: 1012:	YY_BREAK
        -: 1013:case 17:
        -: 1014:YY_RULE_SETUP
        -: 1015:#line 55 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1016:return yy::parser::make_LPAREN(loc);
        -: 1017:	YY_BREAK
        -: 1018:case 18:
        -: 1019:YY_RULE_SETUP
        -: 1020:#line 56 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1021:return yy::parser::make_RPAREN(loc);
        -: 1022:	YY_BREAK
        -: 1023:case 19:
        -: 1024:YY_RULE_SETUP
        -: 1025:#line 57 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1026:return yy::parser::make_LBRACKET(loc);
        -: 1027:	YY_BREAK
        -: 1028:case 20:
        -: 1029:YY_RULE_SETUP
        -: 1030:#line 58 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1031:return yy::parser::make_RBRACKET(loc);
        -: 1032:	YY_BREAK
        -: 1033:case 21:
        -: 1034:YY_RULE_SETUP
        -: 1035:#line 60 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1036:return make_NUMBER(yytext, loc, false);
        -: 1037:	YY_BREAK
        -: 1038:case 22:
        -: 1039:YY_RULE_SETUP
        -: 1040:#line 61 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1041:return make_NUMBER(yytext, loc, true);
        -: 1042:	YY_BREAK
        -: 1043:case 23:
        -: 1044:YY_RULE_SETUP
        -: 1045:#line 62 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1046:return make_IDENTIFIER(yytext, loc);
        -: 1047:	YY_BREAK
        -: 1048:case 24:
        -: 1049:YY_RULE_SETUP
        -: 1050:#line 64 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1051:{
        -: 1052:            throw yy::parser::syntax_error(loc, "invalid character: " + std::string(yytext));
        -: 1053:        }
        -: 1054:	YY_BREAK
        -: 1055:case YY_STATE_EOF(INITIAL):
        -: 1056:#line 69 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1057:return yy::parser::make_YYEOF(loc);
        -: 1058:	YY_BREAK
        -: 1059:case 25:
        -: 1060:YY_RULE_SETUP
        -: 1061:#line 70 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 1062:ECHO;
        -: 1063:	YY_BREAK
        -: 1064:#line 1064 "D:/programming/c/tac_parser/cmake-build-debug-coverage/lexer.cpp"
        3: 1065:
        -: 1066:	case YY_END_OF_BUFFER:
        -: 1067:		{
        3: 1068:		/* Amount of text matched not including the EOB char. */
        -: 1069:		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
        -: 1070:
        3: 1071:		/* Undo the effects of YY_DO_BEFORE_ACTION. */
        -: 1072:		*yy_cp = (yy_hold_char);
        -: 1073:		YY_RESTORE_YY_MORE_OFFSET
        3: 1074:
        3: 1074-block  0
        -: 1075:		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
        -: 1076:			{
        -: 1077:			/* We're scanning a new file or input source.  It's
        -: 1078:			 * possible that this happened because the user
        -: 1079:			 * just pointed yyin at a new source and called
        -: 1080:			 * yylex().  If so, then we have to assure
        -: 1081:			 * consistency between YY_CURRENT_BUFFER and our
        -: 1082:			 * globals.  Here is the right place to do so, because
        -: 1083:			 * this is the first action (other than possibly a
        -: 1084:			 * back-up) that will match for the new input source.
        1: 1085:			 */
        -: 1086:			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
        1: 1087:/* %if-c-only */
        -: 1088:			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
        -: 1089:/* %endif */
        -: 1090:/* %if-c++-only */
        1: 1091:/* %endif */
        1: 1091-block  0
        -: 1092:			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
        -: 1093:			}
        -: 1094:
        -: 1095:		/* Note that here we test for yy_c_buf_p "<=" to the position
        -: 1096:		 * of the first EOB in the buffer, since yy_c_buf_p will
        -: 1097:		 * already have been incremented past the NUL character
        -: 1098:		 * (since all states make transitions on EOB to the
        -: 1099:		 * end-of-buffer state).  Contrast this with the test
        -: 1100:		 * in input().
        3: 1101:		 */
        3: 1101-block  0
        -: 1102:		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
        -: 1103:			{ /* This was really a NUL. */
        -: 1104:			yy_state_type yy_next_state;
    #####: 1105:
        -: 1106:			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
    #####: 1107:
    %%%%%: 1107-block  0
        -: 1108:			yy_current_state = yy_get_previous_state(  );
        -: 1109:
        -: 1110:			/* Okay, we're now positioned to make the NUL
        -: 1111:			 * transition.  We couldn't have
        -: 1112:			 * yy_get_previous_state() go ahead and do it
        -: 1113:			 * for us because it doesn't know how to deal
        -: 1114:			 * with the possibility of jamming (and we don't
        -: 1115:			 * want to build jamming into it because then it
        -: 1116:			 * will run more slowly).
        -: 1117:			 */
    #####: 1118:
        -: 1119:			yy_next_state = yy_try_NUL_trans( yy_current_state );
    #####: 1120:
        -: 1121:			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
    #####: 1122:
        -: 1123:			if ( yy_next_state )
        -: 1124:				{
    #####: 1125:				/* Consume the NUL. */
    #####: 1126:				yy_cp = ++(yy_c_buf_p);
    #####: 1127:				yy_current_state = yy_next_state;
    %%%%%: 1127-block  0
        -: 1128:				goto yy_match;
        -: 1129:				}
        -: 1130:
        -: 1131:			else
        -: 1132:				{
    #####: 1133:/* %% [14.0] code to do back-up for compressed tables and set up yy_cp goes here */
    #####: 1134:				yy_cp = (yy_last_accepting_cpos);
    #####: 1135:				yy_current_state = (yy_last_accepting_state);
    %%%%%: 1135-block  0
        -: 1136:				goto yy_find_action;
        -: 1137:				}
        -: 1138:			}
        3: 1139:
        3: 1139-block  0
        -: 1140:		else switch ( yy_get_next_buffer(  ) )
        1: 1141:			{
        -: 1142:			case EOB_ACT_END_OF_FILE:
        1: 1143:				{
        1: 1143-block  0
        -: 1144:				(yy_did_buffer_switch_on_eof) = 0;
        -: 1145:
        -: 1146:				if ( yywrap(  ) )
        -: 1147:					{
        -: 1148:					/* Note: because we've taken care in
        -: 1149:					 * yy_get_next_buffer() to have set up
        -: 1150:					 * yytext, we can now set up
        -: 1151:					 * yy_c_buf_p so that if some total
        -: 1152:					 * hoser (like flex itself) wants to
        -: 1153:					 * call the scanner after we return the
        -: 1154:					 * YY_NULL, it'll still work - another
        -: 1155:					 * YY_NULL will get returned.
        1: 1156:					 */
        -: 1157:					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
        1: 1158:
        1: 1159:					yy_act = YY_STATE_EOF(YY_START);
        1: 1159-block  0
        -: 1160:					goto do_action;
        -: 1161:					}
        -: 1162:
        -: 1163:				else
        -: 1164:					{
        -: 1165:					if ( ! (yy_did_buffer_switch_on_eof) )
        -: 1166:						YY_NEW_FILE;
        -: 1167:					}
        -: 1168:				break;
        -: 1169:				}
        1: 1170:
        1: 1171:			case EOB_ACT_CONTINUE_SCAN:
        1: 1172:				(yy_c_buf_p) =
        -: 1173:					(yytext_ptr) + yy_amount_of_matched_text;
        1: 1174:
        1: 1174-block  0
        -: 1175:				yy_current_state = yy_get_previous_state(  );
        1: 1176:
        1: 1177:				yy_cp = (yy_c_buf_p);
        1: 1178:				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
        -: 1179:				goto yy_match;
        1: 1180:
        1: 1181:			case EOB_ACT_LAST_MATCH:
        1: 1182:				(yy_c_buf_p) =
        -: 1183:				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
        1: 1184:
        1: 1184-block  0
        -: 1185:				yy_current_state = yy_get_previous_state(  );
        1: 1186:
        1: 1187:				yy_cp = (yy_c_buf_p);
        1: 1188:				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
        -: 1189:				goto yy_find_action;
    #####: 1190:			}
    %%%%%: 1190-block  0
        -: 1191:		break;
        -: 1192:		}
    #####: 1193:
    #####: 1194:	default:
    %%%%%: 1194-block  0
        -: 1195:		YY_FATAL_ERROR(
        -: 1196:			"fatal flex scanner internal error--no action found" );
      178: 1197:	} /* end of action switch */
      178: 1197-block  0
        -: 1198:		} /* end of scanning one token */
        -: 1199:	} /* end of user's declarations */
        -: 1200:} /* end of yylex */
        -: 1201:/* %ok-for-header */
        -: 1202:
        -: 1203:/* %if-c++-only */
        -: 1204:/* %not-for-header */
        -: 1205:/* %ok-for-header */
        -: 1206:
        -: 1207:/* %endif */
        -: 1208:
        -: 1209:/* yy_get_next_buffer - try to read in a new buffer
        -: 1210: *
        -: 1211: * Returns a code representing an action:
        -: 1212: *	EOB_ACT_LAST_MATCH -
        -: 1213: *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
        -: 1214: *	EOB_ACT_END_OF_FILE - end of file
        -: 1215: */
        3: 1216:/* %if-c-only */
        -: 1217:static int yy_get_next_buffer (void)
        -: 1218:/* %endif */
        -: 1219:/* %if-c++-only */
        -: 1220:/* %endif */
        3: 1221:{
        3: 1222:    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        -: 1223:	char *source = (yytext_ptr);
        -: 1224:	int number_to_move, i;
        -: 1225:	int ret_val;
        3: 1226:
        3: 1226-block  0
    #####: 1227:	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
    %%%%%: 1227-block  0
        -: 1228:		YY_FATAL_ERROR(
        -: 1229:		"fatal flex scanner internal error--end of buffer missed" );
        3: 1230:
        3: 1230-block  0
        -: 1231:	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
    #####: 1232:		{ /* Don't try to fill the buffer, so this is an EOF. */
    %%%%%: 1232-block  0
        -: 1233:		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
        -: 1234:			{
        -: 1235:			/* We matched a single character, the EOB, so
        -: 1236:			 * treat this as a final EOF.
    #####: 1237:			 */
    %%%%%: 1237-block  0
        -: 1238:			return EOB_ACT_END_OF_FILE;
        -: 1239:			}
        -: 1240:
        -: 1241:		else
        -: 1242:			{
        -: 1243:			/* We matched some text prior to the EOB, first
        -: 1244:			 * process it.
    #####: 1245:			 */
    %%%%%: 1245-block  0
        -: 1246:			return EOB_ACT_LAST_MATCH;
        -: 1247:			}
        -: 1248:		}
        -: 1249:
        -: 1250:	/* Try to read more data. */
        -: 1251:
        3: 1252:	/* First move last chars to start of buffer. */
        -: 1253:	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
        4: 1254:
        3: 1254-block  0
        4: 1254-block  1
        1: 1255:	for ( i = 0; i < number_to_move; ++i )
        1: 1255-block  0
        -: 1256:		*(dest++) = *(source++);
        3: 1257:
        3: 1257-block  0
        -: 1258:	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
        -: 1259:		/* don't do the read, it's not guaranteed to return an EOF,
        -: 1260:		 * just force an EOF
        1: 1261:		 */
        1: 1261-block  0
        -: 1262:		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
        -: 1263:
        -: 1264:	else
        2: 1265:		{
        2: 1266:			int num_to_read =
        2: 1266-block  0
        -: 1267:			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
       2*: 1268:
        2: 1268-block  0
        -: 1269:		while ( num_to_read <= 0 )
        -: 1270:			{ /* Not enough room in the buffer - grow it. */
        -: 1271:
    #####: 1272:			/* just a shorter name for the current buffer */
        -: 1273:			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
    #####: 1274:
    #####: 1275:			int yy_c_buf_p_offset =
        -: 1276:				(int) ((yy_c_buf_p) - b->yy_ch_buf);
    #####: 1277:
    %%%%%: 1277-block  0
        -: 1278:			if ( b->yy_is_our_buffer )
    #####: 1279:				{
        -: 1280:				int new_size = b->yy_buf_size * 2;
    #####: 1281:
    %%%%%: 1281-block  0
    #####: 1282:				if ( new_size <= 0 )
    %%%%%: 1282-block  0
        -: 1283:					b->yy_buf_size += b->yy_buf_size / 8;
    #####: 1284:				else
    %%%%%: 1284-block  0
        -: 1285:					b->yy_buf_size *= 2;
    #####: 1286:
        -: 1287:				b->yy_ch_buf = (char *)
    #####: 1288:					/* Include room in for 2 EOB chars. */
    #####: 1289:					yyrealloc( (void *) b->yy_ch_buf,
    %%%%%: 1289-block  0
        -: 1290:							 (yy_size_t) (b->yy_buf_size + 2)  );
        -: 1291:				}
        -: 1292:			else
    #####: 1293:				/* Can't grow it, we don't own it. */
    %%%%%: 1293-block  0
        -: 1294:				b->yy_ch_buf = NULL;
    #####: 1295:
    %%%%%: 1295-block  0
    #####: 1296:			if ( ! b->yy_ch_buf )
    %%%%%: 1296-block  0
        -: 1297:				YY_FATAL_ERROR(
        -: 1298:				"fatal error - scanner input buffer overflow" );
    #####: 1299:
        -: 1300:			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
    #####: 1301:
    %%%%%: 1301-block  0
        -: 1302:			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
        -: 1303:						number_to_move - 1;
        -: 1304:
        -: 1305:			}
        2: 1306:
        2: 1306-block  0
        2: 1307:		if ( num_to_read > YY_READ_BUF_SIZE )
        2: 1307-block  0
        -: 1308:			num_to_read = YY_READ_BUF_SIZE;
        -: 1309:
       2*: 1310:		/* Read in more data. */
        2: 1310-block  0
    %%%%%: 1310-block  1
    %%%%%: 1310-block  2
    %%%%%: 1310-block  3
    %%%%%: 1310-block  4
    %%%%%: 1310-block  5
    %%%%%: 1310-block  6
    %%%%%: 1310-block  7
    %%%%%: 1310-block  8
    %%%%%: 1310-block  9
    %%%%%: 1310-block 10
    %%%%%: 1310-block 11
    %%%%%: 1310-block 12
    %%%%%: 1310-block 13
    %%%%%: 1310-block 14
    %%%%%: 1310-block 15
    %%%%%: 1310-block 16
    %%%%%: 1310-block 17
        2: 1310-block 18
        2: 1310-block 19
        1: 1310-block 20
    %%%%%: 1310-block 21
        2: 1310-block 22
        2: 1310-block 23
    %%%%%: 1310-block 24
    %%%%%: 1310-block 25
    %%%%%: 1310-block 26
        -: 1311:		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
        -: 1312:			(yy_n_chars), num_to_read );
        2: 1313:
        2: 1313-block  0
        -: 1314:		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
        -: 1315:		}
        3: 1316:
        3: 1316-block  0
        -: 1317:	if ( (yy_n_chars) == 0 )
        2: 1318:		{
        2: 1318-block  0
        -: 1319:		if ( number_to_move == YY_MORE_ADJ )
        1: 1320:			{
        1: 1321:			ret_val = EOB_ACT_END_OF_FILE;
        1: 1321-block  0
        -: 1322:			yyrestart( yyin  );
        -: 1323:			}
        -: 1324:
        -: 1325:		else
        1: 1326:			{
        1: 1327:			ret_val = EOB_ACT_LAST_MATCH;
        1: 1327-block  0
        -: 1328:			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
        -: 1329:				YY_BUFFER_EOF_PENDING;
        -: 1330:			}
        -: 1331:		}
        -: 1332:
        1: 1333:	else
        1: 1333-block  0
        -: 1334:		ret_val = EOB_ACT_CONTINUE_SCAN;
        3: 1335:
        3: 1335-block  0
        -: 1336:	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
    #####: 1337:		/* Extend the array by 50%, plus the number we really need. */
    #####: 1338:		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
    #####: 1339:		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
    %%%%%: 1339-block  0
    #####: 1340:			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
    #####: 1341:		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
    %%%%%: 1341-block  0
        -: 1342:			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
    #####: 1343:		/* "- 2" to take care of EOB's */
    %%%%%: 1343-block  0
        -: 1344:		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
        -: 1345:	}
        3: 1346:
        3: 1347:	(yy_n_chars) += number_to_move;
        3: 1348:	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
        -: 1349:	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
        3: 1350:
        -: 1351:	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
        3: 1352:
        3: 1352-block  0
        -: 1353:	return ret_val;
        -: 1354:}
        -: 1355:
        -: 1356:/* yy_get_previous_state - get the state just before the EOB char was reached */
        -: 1357:
        -: 1358:/* %if-c-only */
        2: 1359:/* %not-for-header */
        -: 1360:    static yy_state_type yy_get_previous_state (void)
        -: 1361:/* %endif */
        -: 1362:/* %if-c++-only */
        -: 1363:/* %endif */
        -: 1364:{
        -: 1365:	yy_state_type yy_current_state;
        -: 1366:	char *yy_cp;
        -: 1367:    
        2: 1368:/* %% [15.0] code to get the start state into yy_current_state goes here */
        2: 1369:	yy_current_state = (yy_start);
        -: 1370:	yy_current_state += YY_AT_BOL();
        3: 1371:
        2: 1371-block  0
        3: 1371-block  1
        -: 1372:	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
        -: 1373:		{
       1*: 1374:/* %% [16.0] code to find the next state goes here */
        1: 1374-block  0
        1: 1374-block  1
    %%%%%: 1374-block  2
        1: 1375:		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
        1: 1375-block  0
        -: 1376:		if ( yy_accept[yy_current_state] )
    #####: 1377:			{
    #####: 1378:			(yy_last_accepting_state) = yy_current_state;
    %%%%%: 1378-block  0
        -: 1379:			(yy_last_accepting_cpos) = yy_cp;
       1*: 1380:			}
        1: 1380-block  0
    %%%%%: 1380-block  1
        -: 1381:		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
    #####: 1382:			{
    #####: 1383:			yy_current_state = (int) yy_def[yy_current_state];
    %%%%%: 1383-block  0
    #####: 1384:			if ( yy_current_state >= 40 )
    %%%%%: 1384-block  0
        -: 1385:				yy_c = yy_meta[yy_c];
        1: 1386:			}
        1: 1386-block  0
        -: 1387:		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        -: 1388:		}
        2: 1389:
        2: 1389-block  0
        -: 1390:	return yy_current_state;
        -: 1391:}
        -: 1392:
        -: 1393:/* yy_try_NUL_trans - try to make a transition on the NUL character
        -: 1394: *
        -: 1395: * synopsis
        -: 1396: *	next_state = yy_try_NUL_trans( current_state );
        -: 1397: */
    #####: 1398:/* %if-c-only */
        -: 1399:    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
        -: 1400:/* %endif */
        -: 1401:/* %if-c++-only */
        -: 1402:/* %endif */
        -: 1403:{
        -: 1404:	int yy_is_jam;
    #####: 1405:    /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
        -: 1406:	char *yy_cp = (yy_c_buf_p);
    #####: 1407:
    #####: 1408:	YY_CHAR yy_c = 1;
    %%%%%: 1408-block  0
        -: 1409:	if ( yy_accept[yy_current_state] )
    #####: 1410:		{
    #####: 1411:		(yy_last_accepting_state) = yy_current_state;
    %%%%%: 1411-block  0
        -: 1412:		(yy_last_accepting_cpos) = yy_cp;
    #####: 1413:		}
    %%%%%: 1413-block  0
    %%%%%: 1413-block  1
        -: 1414:	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
    #####: 1415:		{
    #####: 1416:		yy_current_state = (int) yy_def[yy_current_state];
    %%%%%: 1416-block  0
    #####: 1417:		if ( yy_current_state >= 40 )
    %%%%%: 1417-block  0
        -: 1418:			yy_c = yy_meta[yy_c];
    #####: 1419:		}
    #####: 1420:	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        -: 1421:	yy_is_jam = (yy_current_state == 39);
    #####: 1422:
    %%%%%: 1422-block  0
    %%%%%: 1422-block  1
    %%%%%: 1422-block  2
    %%%%%: 1422-block  3
        -: 1423:		return yy_is_jam ? 0 : yy_current_state;
        -: 1424:}
        -: 1425:
        -: 1426:#ifndef YY_NO_UNPUT
        -: 1427:/* %if-c-only */
        -: 1428:
        -: 1429:/* %endif */
        -: 1430:#endif
        -: 1431:
        -: 1432:/* %if-c-only */
        -: 1433:#ifndef YY_NO_INPUT
        -: 1434:#ifdef __cplusplus
        -: 1435:    static int yyinput (void)
        -: 1436:#else
        -: 1437:    static int input  (void)
        -: 1438:#endif
        -: 1439:
        -: 1440:/* %endif */
        -: 1441:/* %if-c++-only */
        -: 1442:/* %endif */
        -: 1443:{
        -: 1444:	int c;
        -: 1445:    
        -: 1446:	*(yy_c_buf_p) = (yy_hold_char);
        -: 1447:
        -: 1448:	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
        -: 1449:		{
        -: 1450:		/* yy_c_buf_p now points to the character we want to return.
        -: 1451:		 * If this occurs *before* the EOB characters, then it's a
        -: 1452:		 * valid NUL; if not, then we've hit the end of the buffer.
        -: 1453:		 */
        -: 1454:		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
        -: 1455:			/* This was really a NUL. */
        -: 1456:			*(yy_c_buf_p) = '\0';
        -: 1457:
        -: 1458:		else
        -: 1459:			{ /* need more input */
        -: 1460:			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
        -: 1461:			++(yy_c_buf_p);
        -: 1462:
        -: 1463:			switch ( yy_get_next_buffer(  ) )
        -: 1464:				{
        -: 1465:				case EOB_ACT_LAST_MATCH:
        -: 1466:					/* This happens because yy_g_n_b()
        -: 1467:					 * sees that we've accumulated a
        -: 1468:					 * token and flags that we need to
        -: 1469:					 * try matching the token before
        -: 1470:					 * proceeding.  But for input(),
        -: 1471:					 * there's no matching to consider.
        -: 1472:					 * So convert the EOB_ACT_LAST_MATCH
        -: 1473:					 * to EOB_ACT_END_OF_FILE.
        -: 1474:					 */
        -: 1475:
        -: 1476:					/* Reset buffer status. */
        -: 1477:					yyrestart( yyin );
        -: 1478:
        -: 1479:					/*FALLTHROUGH*/
        -: 1480:
        -: 1481:				case EOB_ACT_END_OF_FILE:
        -: 1482:					{
        -: 1483:					if ( yywrap(  ) )
        -: 1484:						return 0;
        -: 1485:
        -: 1486:					if ( ! (yy_did_buffer_switch_on_eof) )
        -: 1487:						YY_NEW_FILE;
        -: 1488:#ifdef __cplusplus
        -: 1489:					return yyinput();
        -: 1490:#else
        -: 1491:					return input();
        -: 1492:#endif
        -: 1493:					}
        -: 1494:
        -: 1495:				case EOB_ACT_CONTINUE_SCAN:
        -: 1496:					(yy_c_buf_p) = (yytext_ptr) + offset;
        -: 1497:					break;
        -: 1498:				}
        -: 1499:			}
        -: 1500:		}
        -: 1501:
        -: 1502:	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
        -: 1503:	*(yy_c_buf_p) = '\0';	/* preserve yytext */
        -: 1504:	(yy_hold_char) = *++(yy_c_buf_p);
        -: 1505:
        -: 1506:/* %% [19.0] update BOL and yylineno */
        -: 1507:	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
        -: 1508:
        -: 1509:	return c;
        -: 1510:}
        -: 1511:/* %if-c-only */
        -: 1512:#endif	/* ifndef YY_NO_INPUT */
        -: 1513:/* %endif */
        -: 1514:
        -: 1515:/** Immediately switch to a different input stream.
        -: 1516: * @param input_file A readable stream.
        -: 1517: * 
        -: 1518: * @note This function does not reset the start condition to @c INITIAL .
        -: 1519: */
        1: 1520:/* %if-c-only */
        -: 1521:    void yyrestart  (FILE * input_file )
        -: 1522:/* %endif */
        -: 1523:/* %if-c++-only */
        -: 1524:/* %endif */
        -: 1525:{
        1: 1526:    
        1: 1526-block  0
        1: 1526-block  1
    #####: 1527:	if ( ! YY_CURRENT_BUFFER ){
    %%%%%: 1527-block  0
    #####: 1528:        yyensure_buffer_stack ();
    #####: 1529:		YY_CURRENT_BUFFER_LVALUE =
        -: 1530:            yy_create_buffer( yyin, YY_BUF_SIZE );
        -: 1531:	}
       1*: 1532:
        1: 1532-block  0
        1: 1532-block  1
    %%%%%: 1532-block  2
        1: 1532-block  3
        1: 1533:	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
        1: 1534:	yy_load_buffer_state(  );
        -: 1535:}
        -: 1536:
        -: 1537:/* %if-c++-only */
        -: 1538:/* %endif */
        -: 1539:
        -: 1540:/** Switch to a different input buffer.
        -: 1541: * @param new_buffer The new input buffer.
        -: 1542: * 
        -: 1543: */
    #####: 1544:/* %if-c-only */
        -: 1545:    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
        -: 1546:/* %endif */
        -: 1547:/* %if-c++-only */
        -: 1548:/* %endif */
        -: 1549:{
        -: 1550:    
        -: 1551:	/* TODO. We should be able to replace this entire function body
        -: 1552:	 * with
        -: 1553:	 *		yypop_buffer_state();
        -: 1554:	 *		yypush_buffer_state(new_buffer);
    #####: 1555:     */
    %%%%%: 1555-block  0
    #####: 1556:	yyensure_buffer_stack ();
    %%%%%: 1556-block  0
    %%%%%: 1556-block  1
    %%%%%: 1556-block  2
    #####: 1557:	if ( YY_CURRENT_BUFFER == new_buffer )
    %%%%%: 1557-block  0
        -: 1558:		return;
    #####: 1559:
    %%%%%: 1559-block  0
    %%%%%: 1559-block  1
        -: 1560:	if ( YY_CURRENT_BUFFER )
        -: 1561:		{
    #####: 1562:		/* Flush out information for old buffer. */
    #####: 1563:		*(yy_c_buf_p) = (yy_hold_char);
    #####: 1564:		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    %%%%%: 1564-block  0
        -: 1565:		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
        -: 1566:		}
    #####: 1567:
    #####: 1568:	YY_CURRENT_BUFFER_LVALUE = new_buffer;
    %%%%%: 1568-block  0
        -: 1569:	yy_load_buffer_state(  );
        -: 1570:
        -: 1571:	/* We don't actually know whether we did this switch during
        -: 1572:	 * EOF (yywrap()) processing, but the only time this flag
        -: 1573:	 * is looked at is after yywrap() is called, so it's safe
        -: 1574:	 * to go ahead and always set it.
    #####: 1575:	 */
        -: 1576:	(yy_did_buffer_switch_on_eof) = 1;
        -: 1577:}
        -: 1578:
        3: 1579:/* %if-c-only */
        -: 1580:static void yy_load_buffer_state  (void)
        -: 1581:/* %endif */
        -: 1582:/* %if-c++-only */
        -: 1583:/* %endif */
        3: 1584:{
        3: 1585:    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
        -: 1586:	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
        3: 1587:/* %if-c-only */
        -: 1588:	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
        -: 1589:/* %endif */
        -: 1590:/* %if-c++-only */
        3: 1591:/* %endif */
        3: 1592:	(yy_hold_char) = *(yy_c_buf_p);
        -: 1593:}
        -: 1594:
        -: 1595:/** Allocate and initialize an input buffer state.
        -: 1596: * @param file A readable stream.
        -: 1597: * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
        -: 1598: * 
        -: 1599: * @return the allocated buffer state.
        -: 1600: */
        1: 1601:/* %if-c-only */
        -: 1602:    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
        -: 1603:/* %endif */
        -: 1604:/* %if-c++-only */
        -: 1605:/* %endif */
        -: 1606:{
        -: 1607:	YY_BUFFER_STATE b;
        1: 1608:    
        1: 1608-block  0
        1: 1609:	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
    #####: 1610:	if ( ! b )
    %%%%%: 1610-block  0
        -: 1611:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        1: 1612:
        -: 1613:	b->yy_buf_size = size;
        -: 1614:
        -: 1615:	/* yy_ch_buf has to be 2 characters longer than the size given because
        -: 1616:	 * we need to put in 2 end-of-buffer characters.
        1: 1617:	 */
        1: 1617-block  0
        1: 1618:	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
    #####: 1619:	if ( ! b->yy_ch_buf )
    %%%%%: 1619-block  0
        -: 1620:		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
        1: 1621:
        -: 1622:	b->yy_is_our_buffer = 1;
        1: 1623:
        1: 1623-block  0
        -: 1624:	yy_init_buffer( b, file );
        1: 1625:
        -: 1626:	return b;
        -: 1627:}
        -: 1628:
        -: 1629:/* %if-c++-only */
        -: 1630:/* %endif */
        -: 1631:
        -: 1632:/** Destroy the buffer.
        -: 1633: * @param b a buffer created with yy_create_buffer()
        -: 1634: * 
        -: 1635: */
    #####: 1636:/* %if-c-only */
        -: 1637:    void yy_delete_buffer (YY_BUFFER_STATE  b )
        -: 1638:/* %endif */
        -: 1639:/* %if-c++-only */
        -: 1640:/* %endif */
        -: 1641:{
    #####: 1642:    
    %%%%%: 1642-block  0
    #####: 1643:	if ( ! b )
    %%%%%: 1643-block  0
        -: 1644:		return;
    #####: 1645:
    %%%%%: 1645-block  0
    %%%%%: 1645-block  1
    %%%%%: 1645-block  2
    %%%%%: 1645-block  3
    #####: 1646:	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
    %%%%%: 1646-block  0
        -: 1647:		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
    #####: 1648:
    %%%%%: 1648-block  0
    #####: 1649:	if ( b->yy_is_our_buffer )
    %%%%%: 1649-block  0
        -: 1650:		yyfree( (void *) b->yy_ch_buf  );
    #####: 1651:
    %%%%%: 1651-block  0
        -: 1652:	yyfree( (void *) b  );
        -: 1653:}
        -: 1654:
        -: 1655:/* Initializes or reinitializes a buffer.
        -: 1656: * This function is sometimes called more than once on the same buffer,
        -: 1657: * such as during a yyrestart() or at EOF.
        -: 1658: */
        2: 1659:/* %if-c-only */
        -: 1660:    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
        -: 1661:/* %endif */
        -: 1662:/* %if-c++-only */
        -: 1663:/* %endif */
        -: 1664:
        2: 1665:{
        2: 1665-block  0
        -: 1666:	int oerrno = errno;
        2: 1667:    
        -: 1668:	yy_flush_buffer( b );
        -: 1669:
        2: 1670:/* %if-c-only */
        -: 1671:	b->yy_input_file = file;
        -: 1672:/* %endif */
        -: 1673:/* %if-c++-only */
        2: 1674:/* %endif */
        -: 1675:	b->yy_fill_buffer = 1;
        -: 1676:
        -: 1677:    /* If b is the current buffer, then yy_init_buffer was _probably_
        -: 1678:     * called from yyrestart() or through yy_get_next_buffer.
        -: 1679:     * In that case, we don't want to reset the lineno or column.
       2*: 1680:     */
        2: 1680-block  0
    %%%%%: 1680-block  1
        2: 1680-block  2
        1: 1681:    if (b != YY_CURRENT_BUFFER){
        1: 1682:        b->yy_bs_lineno = 1;
        1: 1682-block  0
        -: 1683:        b->yy_bs_column = 0;
        -: 1684:    }
        -: 1685:
        -: 1686:/* %if-c-only */
       2*: 1687:
        2: 1687-block  0
        2: 1687-block  1
    %%%%%: 1687-block  2
        2: 1687-block  3
        -: 1688:        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
        -: 1689:    
        -: 1690:/* %endif */
        -: 1691:/* %if-c++-only */
        2: 1692:/* %endif */
        2: 1692-block  0
        2: 1693:	errno = oerrno;
        -: 1694:}
        -: 1695:
        -: 1696:/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
        -: 1697: * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
        -: 1698: * 
        -: 1699: */
        2: 1700:/* %if-c-only */
        -: 1701:    void yy_flush_buffer (YY_BUFFER_STATE  b )
        -: 1702:/* %endif */
        -: 1703:/* %if-c++-only */
        -: 1704:/* %endif */
        2: 1705:{
        2: 1705-block  0
    #####: 1706:    	if ( ! b )
    %%%%%: 1706-block  0
        -: 1707:		return;
        2: 1708:
        -: 1709:	b->yy_n_chars = 0;
        -: 1710:
        -: 1711:	/* We always need two end-of-buffer characters.  The first causes
        -: 1712:	 * a transition to the end-of-buffer state.  The second causes
        -: 1713:	 * a jam in that state.
        2: 1714:	 */
        2: 1715:	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
        -: 1716:	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
        2: 1717:
        -: 1718:	b->yy_buf_pos = &b->yy_ch_buf[0];
        2: 1719:
        2: 1720:	b->yy_at_bol = 1;
        -: 1721:	b->yy_buffer_status = YY_BUFFER_NEW;
       2*: 1722:
        2: 1722-block  0
        2: 1722-block  1
    %%%%%: 1722-block  2
        2: 1722-block  3
        1: 1723:	if ( b == YY_CURRENT_BUFFER )
        1: 1723-block  0
        -: 1724:		yy_load_buffer_state(  );
        -: 1725:}
        -: 1726:
        -: 1727:/* %if-c-or-c++ */
        -: 1728:/** Pushes the new state onto the stack. The new state becomes
        -: 1729: *  the current state. This function will allocate the stack
        -: 1730: *  if necessary.
        -: 1731: *  @param new_buffer The new state.
        -: 1732: *  
        -: 1733: */
    #####: 1734:/* %if-c-only */
        -: 1735:void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
        -: 1736:/* %endif */
        -: 1737:/* %if-c++-only */
        -: 1738:/* %endif */
    #####: 1739:{
    %%%%%: 1739-block  0
    #####: 1740:    	if (new_buffer == NULL)
    %%%%%: 1740-block  0
        -: 1741:		return;
    #####: 1742:
    %%%%%: 1742-block  0
        -: 1743:	yyensure_buffer_stack();
        -: 1744:
    #####: 1745:	/* This block is copied from yy_switch_to_buffer. */
    %%%%%: 1745-block  0
        -: 1746:	if ( YY_CURRENT_BUFFER )
        -: 1747:		{
    #####: 1748:		/* Flush out information for old buffer. */
    #####: 1749:		*(yy_c_buf_p) = (yy_hold_char);
    #####: 1750:		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    %%%%%: 1750-block  0
        -: 1751:		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
        -: 1752:		}
        -: 1753:
    #####: 1754:	/* Only push if top exists. Otherwise, replace top. */
    %%%%%: 1754-block  0
    %%%%%: 1754-block  1
    #####: 1755:	if (YY_CURRENT_BUFFER)
    %%%%%: 1755-block  0
    #####: 1756:		(yy_buffer_stack_top)++;
        -: 1757:	YY_CURRENT_BUFFER_LVALUE = new_buffer;
        -: 1758:
    #####: 1759:	/* copied from yy_switch_to_buffer. */
    %%%%%: 1759-block  0
    #####: 1760:	yy_load_buffer_state(  );
        -: 1761:	(yy_did_buffer_switch_on_eof) = 1;
        -: 1762:}
        -: 1763:/* %endif */
        -: 1764:
        -: 1765:/* %if-c-or-c++ */
        -: 1766:/** Removes and deletes the top of the stack, if present.
        -: 1767: *  The next element becomes the new top.
        -: 1768: *  
        -: 1769: */
    #####: 1770:/* %if-c-only */
        -: 1771:void yypop_buffer_state (void)
        -: 1772:/* %endif */
        -: 1773:/* %if-c++-only */
        -: 1774:/* %endif */
    #####: 1775:{
    %%%%%: 1775-block  0
    %%%%%: 1775-block  1
    #####: 1776:    	if (!YY_CURRENT_BUFFER)
    %%%%%: 1776-block  0
        -: 1777:		return;
    #####: 1778:
    %%%%%: 1778-block  0
    %%%%%: 1778-block  1
    %%%%%: 1778-block  2
    %%%%%: 1778-block  3
    #####: 1779:	yy_delete_buffer(YY_CURRENT_BUFFER );
    #####: 1780:	YY_CURRENT_BUFFER_LVALUE = NULL;
    #####: 1781:	if ((yy_buffer_stack_top) > 0)
    %%%%%: 1781-block  0
        -: 1782:		--(yy_buffer_stack_top);
    #####: 1783:
    %%%%%: 1783-block  0
    %%%%%: 1783-block  1
    #####: 1784:	if (YY_CURRENT_BUFFER) {
    %%%%%: 1784-block  0
    #####: 1785:		yy_load_buffer_state(  );
        -: 1786:		(yy_did_buffer_switch_on_eof) = 1;
        -: 1787:	}
        -: 1788:}
        -: 1789:/* %endif */
        -: 1790:
        -: 1791:/* %if-c-or-c++ */
        -: 1792:/* Allocates the stack if it does not exist.
        -: 1793: *  Guarantees space for at least one push.
        -: 1794: */
        1: 1795:/* %if-c-only */
        -: 1796:static void yyensure_buffer_stack (void)
        -: 1797:/* %endif */
        -: 1798:/* %if-c++-only */
        -: 1799:/* %endif */
        -: 1800:{
        -: 1801:	yy_size_t num_to_alloc;
        1: 1802:    
        1: 1802-block  0
        -: 1803:	if (!(yy_buffer_stack)) {
        -: 1804:
        -: 1805:		/* First allocation is just for 2 elements, since we don't know if this
        -: 1806:		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
        -: 1807:		 * immediate realloc on the next call.
        1: 1808:         */
        1: 1809:      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
        1: 1810:		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
        1: 1810-block  0
        -: 1811:								(num_to_alloc * sizeof(struct yy_buffer_state*)
        1: 1812:								);
    #####: 1813:		if ( ! (yy_buffer_stack) )
    %%%%%: 1813-block  0
        -: 1814:			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
        1: 1815:
        -: 1816:		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
        1: 1817:
        1: 1818:		(yy_buffer_stack_max) = num_to_alloc;
        1: 1819:		(yy_buffer_stack_top) = 0;
        1: 1819-block  0
        -: 1820:		return;
        -: 1821:	}
    #####: 1822:
    %%%%%: 1822-block  0
        -: 1823:	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
        -: 1824:
    #####: 1825:		/* Increase the buffer to prepare for a possible push. */
        -: 1826:		yy_size_t grow_size = 8 /* arbitrary grow size */;
    #####: 1827:
    #####: 1828:		num_to_alloc = (yy_buffer_stack_max) + grow_size;
    #####: 1829:		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
    %%%%%: 1829-block  0
        -: 1830:								((yy_buffer_stack),
        -: 1831:								num_to_alloc * sizeof(struct yy_buffer_state*)
    #####: 1832:								);
    #####: 1833:		if ( ! (yy_buffer_stack) )
    %%%%%: 1833-block  0
        -: 1834:			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
        -: 1835:
    #####: 1836:		/* zero only the new slots.*/
    #####: 1837:		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
    %%%%%: 1837-block  0
        -: 1838:		(yy_buffer_stack_max) = num_to_alloc;
        -: 1839:	}
        -: 1840:}
        -: 1841:/* %endif */
        -: 1842:
        -: 1843:/* %if-c-only */
        -: 1844:/** Setup the input buffer state to scan directly from a user-specified character buffer.
        -: 1845: * @param base the character buffer
        -: 1846: * @param size the size in bytes of the character buffer
        -: 1847: * 
        -: 1848: * @return the newly allocated buffer state object.
    #####: 1849: */
        -: 1850:YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
        -: 1851:{
        -: 1852:	YY_BUFFER_STATE b;
    #####: 1853:    
    %%%%%: 1853-block  0
    #####: 1854:	if ( size < 2 ||
    %%%%%: 1854-block  0
    #####: 1855:	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
    %%%%%: 1855-block  0
        -: 1856:	     base[size-1] != YY_END_OF_BUFFER_CHAR )
    #####: 1857:		/* They forgot to leave room for the EOB's. */
    %%%%%: 1857-block  0
        -: 1858:		return NULL;
    #####: 1859:
    %%%%%: 1859-block  0
    #####: 1860:	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
    #####: 1861:	if ( ! b )
    %%%%%: 1861-block  0
        -: 1862:		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
    #####: 1863:
    #####: 1864:	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
    #####: 1865:	b->yy_buf_pos = b->yy_ch_buf = base;
    #####: 1866:	b->yy_is_our_buffer = 0;
    #####: 1867:	b->yy_input_file = NULL;
    #####: 1868:	b->yy_n_chars = b->yy_buf_size;
    #####: 1869:	b->yy_is_interactive = 0;
    #####: 1870:	b->yy_at_bol = 1;
    #####: 1871:	b->yy_fill_buffer = 0;
        -: 1872:	b->yy_buffer_status = YY_BUFFER_NEW;
    #####: 1873:
    %%%%%: 1873-block  0
        -: 1874:	yy_switch_to_buffer( b  );
    #####: 1875:
        -: 1876:	return b;
        -: 1877:}
        -: 1878:/* %endif */
        -: 1879:
        -: 1880:/* %if-c-only */
        -: 1881:/** Setup the input buffer state to scan a string. The next call to yylex() will
        -: 1882: * scan from a @e copy of @a str.
        -: 1883: * @param yystr a NUL-terminated string to scan
        -: 1884: * 
        -: 1885: * @return the newly allocated buffer state object.
        -: 1886: * @note If you want to scan bytes that may contain NUL values, then use
        -: 1887: *       yy_scan_bytes() instead.
    #####: 1888: */
        -: 1889:YY_BUFFER_STATE yy_scan_string (const char * yystr )
        -: 1890:{
    #####: 1891:    
    %%%%%: 1891-block  0
        -: 1892:	return yy_scan_bytes( yystr, (int) strlen(yystr) );
        -: 1893:}
        -: 1894:/* %endif */
        -: 1895:
        -: 1896:/* %if-c-only */
        -: 1897:/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
        -: 1898: * scan from a @e copy of @a bytes.
        -: 1899: * @param yybytes the byte buffer to scan
        -: 1900: * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
        -: 1901: * 
        -: 1902: * @return the newly allocated buffer state object.
    #####: 1903: */
        -: 1904:YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
        -: 1905:{
        -: 1906:	YY_BUFFER_STATE b;
        -: 1907:	char *buf;
        -: 1908:	yy_size_t n;
        -: 1909:	int i;
        -: 1910:    
    #####: 1911:	/* Get memory for full buffer, including space for trailing EOB's. */
    #####: 1912:	n = (yy_size_t) (_yybytes_len + 2);
    %%%%%: 1912-block  0
    #####: 1913:	buf = (char *) yyalloc( n  );
    #####: 1914:	if ( ! buf )
    %%%%%: 1914-block  0
        -: 1915:		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
    #####: 1916:
    %%%%%: 1916-block  0
    %%%%%: 1916-block  1
    #####: 1917:	for ( i = 0; i < _yybytes_len; ++i )
    %%%%%: 1917-block  0
        -: 1918:		buf[i] = yybytes[i];
    #####: 1919:
        -: 1920:	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
    #####: 1921:
    %%%%%: 1921-block  0
    #####: 1922:	b = yy_scan_buffer( buf, n );
    #####: 1923:	if ( ! b )
    %%%%%: 1923-block  0
        -: 1924:		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
        -: 1925:
        -: 1926:	/* It's okay to grow etc. this buffer, and we should throw it
        -: 1927:	 * away when we're done.
    #####: 1928:	 */
        -: 1929:	b->yy_is_our_buffer = 1;
    #####: 1930:
    %%%%%: 1930-block  0
        -: 1931:	return b;
        -: 1932:}
        -: 1933:/* %endif */
        -: 1934:
        -: 1935:#ifndef YY_EXIT_FAILURE
        -: 1936:#define YY_EXIT_FAILURE 2
        -: 1937:#endif
        -: 1938:
    #####: 1939:/* %if-c-only */
        -: 1940:static void yynoreturn yy_fatal_error (const char* msg )
    #####: 1941:{
    %%%%%: 1941-block  0
    #####: 1942:			fprintf( stderr, "%s\n", msg );
        -: 1943:	exit( YY_EXIT_FAILURE );
        -: 1944:}
        -: 1945:/* %endif */
        -: 1946:/* %if-c++-only */
        -: 1947:/* %endif */
        -: 1948:
        -: 1949:/* Redefine yyless() so it works in section 3 code. */
        -: 1950:
        -: 1951:#undef yyless
        -: 1952:#define yyless(n) \
        -: 1953:	do \
        -: 1954:		{ \
        -: 1955:		/* Undo effects of setting up yytext. */ \
        -: 1956:        int yyless_macro_arg = (n); \
        -: 1957:        YY_LESS_LINENO(yyless_macro_arg);\
        -: 1958:		yytext[yyleng] = (yy_hold_char); \
        -: 1959:		(yy_c_buf_p) = yytext + yyless_macro_arg; \
        -: 1960:		(yy_hold_char) = *(yy_c_buf_p); \
        -: 1961:		*(yy_c_buf_p) = '\0'; \
        -: 1962:		yyleng = yyless_macro_arg; \
        -: 1963:		} \
        -: 1964:	while ( 0 )
        -: 1965:
        -: 1966:/* Accessor  methods (get/set functions) to struct members. */
        -: 1967:
        -: 1968:/* %if-c-only */
        -: 1969:/* %if-reentrant */
        -: 1970:/* %endif */
        -: 1971:
        -: 1972:/** Get the current line number.
        -: 1973: * 
    #####: 1974: */
        -: 1975:int yyget_lineno  (void)
        -: 1976:{
    #####: 1977:    
    %%%%%: 1977-block  0
        -: 1978:    return yylineno;
        -: 1979:}
        -: 1980:
        -: 1981:/** Get the input stream.
        -: 1982: * 
    #####: 1983: */
        -: 1984:FILE *yyget_in  (void)
    #####: 1985:{
    %%%%%: 1985-block  0
        -: 1986:        return yyin;
        -: 1987:}
        -: 1988:
        -: 1989:/** Get the output stream.
        -: 1990: * 
    #####: 1991: */
        -: 1992:FILE *yyget_out  (void)
    #####: 1993:{
    %%%%%: 1993-block  0
        -: 1994:        return yyout;
        -: 1995:}
        -: 1996:
        -: 1997:/** Get the length of the current token.
        -: 1998: * 
    #####: 1999: */
        -: 2000:int yyget_leng  (void)
    #####: 2001:{
    %%%%%: 2001-block  0
        -: 2002:        return yyleng;
        -: 2003:}
        -: 2004:
        -: 2005:/** Get the current token.
        -: 2006: * 
        -: 2007: */
    #####: 2008:
        -: 2009:char *yyget_text  (void)
    #####: 2010:{
    %%%%%: 2010-block  0
        -: 2011:        return yytext;
        -: 2012:}
        -: 2013:
        -: 2014:/* %if-reentrant */
        -: 2015:/* %endif */
        -: 2016:
        -: 2017:/** Set the current line number.
        -: 2018: * @param _line_number line number
        -: 2019: * 
    #####: 2020: */
        -: 2021:void yyset_lineno (int  _line_number )
        -: 2022:{
    #####: 2023:    
    #####: 2024:    yylineno = _line_number;
        -: 2025:}
        -: 2026:
        -: 2027:/** Set the input stream. This does not discard the current
        -: 2028: * input buffer.
        -: 2029: * @param _in_str A readable stream.
        -: 2030: * 
        -: 2031: * @see yy_switch_to_buffer
    #####: 2032: */
        -: 2033:void yyset_in (FILE *  _in_str )
    #####: 2034:{
    #####: 2035:        yyin = _in_str ;
        -: 2036:}
    #####: 2037:
        -: 2038:void yyset_out (FILE *  _out_str )
    #####: 2039:{
    #####: 2040:        yyout = _out_str ;
        -: 2041:}
    #####: 2042:
        -: 2043:int yyget_debug  (void)
    #####: 2044:{
    %%%%%: 2044-block  0
        -: 2045:        return yy_flex_debug;
        -: 2046:}
    #####: 2047:
        -: 2048:void yyset_debug (int  _bdebug )
    #####: 2049:{
    #####: 2050:        yy_flex_debug = _bdebug ;
        -: 2051:}
        -: 2052:
        -: 2053:/* %endif */
        -: 2054:
        -: 2055:/* %if-reentrant */
        -: 2056:/* %if-bison-bridge */
        -: 2057:/* %endif */
        -: 2058:/* %endif if-c-only */
        -: 2059:
    #####: 2060:/* %if-c-only */
        -: 2061:static int yy_init_globals (void)
        -: 2062:{
        -: 2063:        /* Initialization is the same as for the non-reentrant scanner.
        -: 2064:     * This function is called from yylex_destroy(), so don't allocate here.
        -: 2065:     */
    #####: 2066:
    #####: 2067:    (yy_buffer_stack) = NULL;
    #####: 2068:    (yy_buffer_stack_top) = 0;
    #####: 2069:    (yy_buffer_stack_max) = 0;
    #####: 2070:    (yy_c_buf_p) = NULL;
    #####: 2071:    (yy_init) = 0;
        -: 2072:    (yy_start) = 0;
        -: 2073:
        -: 2074:/* Defined in main.c */
        -: 2075:#ifdef YY_STDINIT
        -: 2076:    yyin = stdin;
        -: 2077:    yyout = stdout;
    #####: 2078:#else
    #####: 2079:    yyin = NULL;
        -: 2080:    yyout = NULL;
        -: 2081:#endif
        -: 2082:
        -: 2083:    /* For future reference: Set errno on error, since we are called by
        -: 2084:     * yylex_init()
    #####: 2085:     */
    %%%%%: 2085-block  0
        -: 2086:    return 0;
        -: 2087:}
        -: 2088:/* %endif */
        -: 2089:
        -: 2090:/* %if-c-only SNIP! this currently causes conflicts with the c++ scanner */
    #####: 2091:/* yylex_destroy is for both reentrant and non-reentrant scanners. */
        -: 2092:int yylex_destroy  (void)
        -: 2093:{
        -: 2094:    
    #####: 2095:    /* Pop the buffer stack, destroying each element. */
    %%%%%: 2095-block  0
    %%%%%: 2095-block  1
    #####: 2096:	while(YY_CURRENT_BUFFER){
    %%%%%: 2096-block  0
    %%%%%: 2096-block  1
    %%%%%: 2096-block  2
    %%%%%: 2096-block  3
    #####: 2097:		yy_delete_buffer( YY_CURRENT_BUFFER  );
    #####: 2098:		YY_CURRENT_BUFFER_LVALUE = NULL;
        -: 2099:		yypop_buffer_state();
        -: 2100:	}
        -: 2101:
    #####: 2102:	/* Destroy the stack itself. */
    %%%%%: 2102-block  0
    #####: 2103:	yyfree((yy_buffer_stack) );
        -: 2104:	(yy_buffer_stack) = NULL;
        -: 2105:
        -: 2106:    /* Reset the globals. This is important in a non-reentrant scanner so the next time
    #####: 2107:     * yylex() is called, initialization will occur. */
        -: 2108:    yy_init_globals( );
        -: 2109:
        -: 2110:/* %if-reentrant */
    #####: 2111:/* %endif */
        -: 2112:    return 0;
        -: 2113:}
        -: 2114:/* %endif */
        -: 2115:
        -: 2116:/*
        -: 2117: * Internal utility routines.
        -: 2118: */
        -: 2119:
        -: 2120:#ifndef yytext_ptr
        -: 2121:static void yy_flex_strncpy (char* s1, const char * s2, int n )
        -: 2122:{
        -: 2123:		
        -: 2124:	int i;
        -: 2125:	for ( i = 0; i < n; ++i )
        -: 2126:		s1[i] = s2[i];
        -: 2127:}
        -: 2128:#endif
        -: 2129:
        -: 2130:#ifdef YY_NEED_STRLEN
        -: 2131:static int yy_flex_strlen (const char * s )
        -: 2132:{
        -: 2133:	int n;
        -: 2134:	for ( n = 0; s[n]; ++n )
        -: 2135:		;
        -: 2136:
        -: 2137:	return n;
        -: 2138:}
        -: 2139:#endif
        3: 2140:
        -: 2141:void *yyalloc (yy_size_t  size )
        3: 2142:{
        3: 2142-block  0
        -: 2143:			return malloc(size);
        -: 2144:}
    #####: 2145:
        -: 2146:void *yyrealloc  (void * ptr, yy_size_t  size )
        -: 2147:{
        -: 2148:		
        -: 2149:	/* The cast to (char *) in the following accommodates both
        -: 2150:	 * implementations that use char* generic pointers, and those
        -: 2151:	 * that use void* generic pointers.  It works with the latter
        -: 2152:	 * because both ANSI C and C++ allow castless assignment from
        -: 2153:	 * any pointer type to void*, and deal with argument conversions
        -: 2154:	 * as though doing an assignment.
    #####: 2155:	 */
    %%%%%: 2155-block  0
        -: 2156:	return realloc(ptr, size);
        -: 2157:}
    #####: 2158:
        -: 2159:void yyfree (void * ptr )
    #####: 2160:{
    #####: 2161:			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
        -: 2162:}
        -: 2163:
        -: 2164:/* %if-tables-serialization definitions */
        -: 2165:/* %define-yytables   The name for this specific scanner's tables. */
        -: 2166:#define YYTABLES_NAME "yytables"
        -: 2167:/* %endif */
        -: 2168:
        -: 2169:/* %ok-for-header */
        -: 2170:
        -: 2171:#line 70 "D:/programming/c/tac_parser/grammar/lexer.l"
        -: 2172:
        -: 2173:
        -: 2174:yy::parser::symbol_type make_NUMBER(const std::string& s, const yy::parser::location_type& loc, bool is_int) {
        -: 2175:    errno = 0;
        -: 2176:    if (is_int) {
        -: 2177:        long n = strtol(s.c_str(), NULL, 10);
        -: 2178:        if (! (INT_MIN <= n && n <= INT_MAX && errno != ERANGE))
        -: 2179:            throw yy::parser::syntax_error(loc, "integer is out of range: " + s);
        -: 2180:        return yy::parser::make_INT((int)n, loc);
        -: 2181:    } else {
        -: 2182:        double n = strtod(s.c_str(), NULL);
        -: 2183:        return yy::parser::make_FLOAT(n, loc);
        -: 2184:    }
        -: 2185:}
        -: 2186:
        -: 2187:yy::parser::symbol_type make_IDENTIFIER(const std::string& s, const yy::parser::location_type& loc) {
        -: 2188:    std::map<std::string, std::function<yy::parser::symbol_type(const yy::parser::location_type&)>> keywords = {
        -: 2189:            {"if", yy::parser::make_IFTRUE },
        -: 2190:            {"ifTrue", yy::parser::make_IFTRUE },
        -: 2191:            {"ifFalse", yy::parser::make_IFFALSE },
        -: 2192:            {"goto", yy::parser::make_GOTO },
        -: 2193:            {"halt", yy::parser::make_HALT },
        -: 2194:            {"param", yy::parser::make_PARAM },
        -: 2195:            {"call", yy::parser::make_CALL },
        -: 2196:            {"nop", yy::parser::make_NOP },
        -: 2197:            {"return", yy::parser::make_RETURN },
        -: 2198:    };
        -: 2199:
        -: 2200:    if (auto f = keywords.find(s); f != keywords.end()) return f->second(loc);
        -: 2201:    else return yy::parser::make_IDENTIFIER(s, loc);
        -: 2202:}
        -: 2203:
        -: 2204:void driver::scan_begin()
        -: 2205:{
        -: 2206:    yy_flex_debug = trace_scanning;
        -: 2207:    // yy_flex_debug = 1;
        -: 2208:    if (file.empty() || file == "-")
        -: 2209:        yyin = stdin;
        -: 2210:    else if (!(yyin = fopen(file.c_str(), "r")))
        -: 2211:    {
        -: 2212:        std::cerr << "cannot open " << file << ": " << strerror(errno) << std::endl;
        -: 2213:        exit(EXIT_FAILURE);
        -: 2214:    }
        -: 2215:}
        -: 2216:
        -: 2217:void driver::scan_end() {
        -: 2218:    fclose(yyin);
        -: 2219:}
